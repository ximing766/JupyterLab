<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>UWBDash API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>UWBDash</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="UWBDash.ChartUpdateThread"><code class="flex name class">
<span>class <span class="ident">ChartUpdateThread</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChartUpdateThread(QThread):
    update_chart = pyqtSignal(str, int)  # å‘é€å›¾è¡¨æ›´æ–°ä¿¡å·
    
    def __init__(self):
        super().__init__()
        self.running    = True
        self.data_queue = queue.Queue()
    
    def add_data(self, chart_key, value):
        self.data_queue.put((chart_key, value))
    
    def stop(self):
        self.running = False
    
    def run(self):
        while self.running:
            try:
                chart_key, value = self.data_queue.get(timeout=0.1)
                self.update_chart.emit(chart_key, value)
            except queue.Empty:
                continue</code></pre>
</details>
<div class="desc"><p>QThread(parent: Optional[QObject] = None)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtCore.QThread</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.ChartUpdateThread.add_data"><code class="name flex">
<span>def <span class="ident">add_data</span></span>(<span>self, chart_key, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_data(self, chart_key, value):
    self.data_queue.put((chart_key, value))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.ChartUpdateThread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    while self.running:
        try:
            chart_key, value = self.data_queue.get(timeout=0.1)
            self.update_chart.emit(chart_key, value)
        except queue.Empty:
            continue</code></pre>
</details>
<div class="desc"><p>run(self)</p></div>
</dd>
<dt id="UWBDash.ChartUpdateThread.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.running = False</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.ChartUpdateThread.update_chart"><code class="name flex">
<span>def <span class="ident">update_chart</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.FindThread"><code class="flex name class">
<span>class <span class="ident">FindThread</span></span>
<span>(</span><span>text, keyword, current_pos, forward)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FindThread(QThread):
    result_ready = pyqtSignal(int, int, list)  # å½“å‰ç´¢å¼•, æ€»æ•°, æ‰€æœ‰åŒ¹é…ä½ç½®

    def __init__(self, text, keyword, current_pos, forward):
        super().__init__()
        self.text        = text
        self.keyword     = keyword
        self.current_pos = current_pos
        self.forward     = forward

    def run(self):
        positions = []
        idx       = self.text.find(self.keyword)
        while idx != -1:
            positions.append(idx)
            idx = self.text.find(self.keyword, idx + len(self.keyword))
        total = len(positions)
        current = 0
        if total &gt; 0:
            # å®šä½åˆ°ä¸‹ä¸€ä¸ª/ä¸Šä¸€ä¸ª
            if self.forward:
                for i, pos in enumerate(positions):
                    if pos &gt; self.current_pos:
                        current = i
                        break
                else:
                    current = 0  # å¾ªç¯åˆ°ç¬¬ä¸€ä¸ª
            else:
                for i in reversed(range(total)):
                    if positions[i] &lt; self.current_pos:
                        current = i
                        break
                else:
                    current = total - 1  # å¾ªç¯åˆ°æœ€åä¸€ä¸ª
        self.result_ready.emit(current, total, positions)</code></pre>
</details>
<div class="desc"><p>QThread(parent: Optional[QObject] = None)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtCore.QThread</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.FindThread.result_ready"><code class="name flex">
<span>def <span class="ident">result_ready</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="UWBDash.FindThread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    positions = []
    idx       = self.text.find(self.keyword)
    while idx != -1:
        positions.append(idx)
        idx = self.text.find(self.keyword, idx + len(self.keyword))
    total = len(positions)
    current = 0
    if total &gt; 0:
        # å®šä½åˆ°ä¸‹ä¸€ä¸ª/ä¸Šä¸€ä¸ª
        if self.forward:
            for i, pos in enumerate(positions):
                if pos &gt; self.current_pos:
                    current = i
                    break
            else:
                current = 0  # å¾ªç¯åˆ°ç¬¬ä¸€ä¸ª
        else:
            for i in reversed(range(total)):
                if positions[i] &lt; self.current_pos:
                    current = i
                    break
            else:
                current = total - 1  # å¾ªç¯åˆ°æœ€åä¸€ä¸ª
    self.result_ready.emit(current, total, positions)</code></pre>
</details>
<div class="desc"><p>run(self)</p></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.HighlightConfigDialog"><code class="flex name class">
<span>class <span class="ident">HighlightConfigDialog</span></span>
<span>(</span><span>current_config, parent=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HighlightConfigDialog(QDialog):
    &#34;&#34;&#34;é…ç½®é«˜äº®å…³é”®å­—å’Œé¢œè‰²çš„å¯¹è¯æ¡†&#34;&#34;&#34;
    def __init__(self, current_config, parent=None):
        super().__init__(parent)
        self.setWindowTitle(&#34;é…ç½®é«˜äº®å…³é”®å­—&#34;)
        self.setMinimumWidth(450)
        self.config = current_config.copy() # ä½¿ç”¨ä¼ å…¥é…ç½®çš„å‰¯æœ¬

        layout = QVBoxLayout(self)

        # è¡¨æ ¼æ˜¾ç¤ºå…³é”®å­—å’Œé¢œè‰²
        self.table = QTableWidget()
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels([&#34;å…³é”®å­—&#34;, &#34;é¢œè‰²é¢„è§ˆ&#34;, &#34;é¢œè‰²å€¼ (Hex)&#34;])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Fixed)
        self.table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        self.table.setColumnWidth(1, 80)
        self.table.setColumnWidth(2, 100)
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers) # ç¦æ­¢ç›´æ¥ç¼–è¾‘
        self.table.verticalHeader().setVisible(False)
        layout.addWidget(self.table)

        # æŒ‰é’®åŒºåŸŸ
        button_layout = QHBoxLayout()
        add_btn       = QPushButton(&#34;æ·»åŠ &#34;)
        add_btn.clicked.connect(self.add_keyword)
        edit_btn = QPushButton(&#34;ç¼–è¾‘&#34;)
        edit_btn.clicked.connect(self.edit_keyword)
        remove_btn = QPushButton(&#34;åˆ é™¤&#34;)
        remove_btn.clicked.connect(self.remove_keyword)

        button_layout.addWidget(add_btn)
        button_layout.addWidget(edit_btn)
        button_layout.addWidget(remove_btn)
        button_layout.addStretch()
        layout.addLayout(button_layout)

        # OK / Cancel æŒ‰é’®
        dialog_buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        dialog_buttons.accepted.connect(self.accept)
        dialog_buttons.rejected.connect(self.reject)
        layout.addWidget(dialog_buttons)

        self.populate_table()

    def populate_table(self):
        &#34;&#34;&#34;ç”¨å½“å‰é…ç½®å¡«å……è¡¨æ ¼&#34;&#34;&#34;
        self.table.setRowCount(0) # æ¸…ç©ºè¡¨æ ¼
        for keyword, color in self.config.items():
            row_position = self.table.rowCount()
            self.table.insertRow(row_position)

            # å…³é”®å­—
            self.table.setItem(row_position, 0, QTableWidgetItem(keyword))

            color_label = QLabel()
            color_label.setStyleSheet(f&#34;background-color: {color.name()}; border: 1px solid #555;&#34;) # ç›´æ¥è®¾ç½®èƒŒæ™¯è‰²å’Œè¾¹æ¡†
            self.table.setCellWidget(row_position, 1, color_label)

            # é¢œè‰²å€¼
            hex_color = color.name().upper()
            self.table.setItem(row_position, 2, QTableWidgetItem(hex_color))

    def add_keyword(self):
        keyword, ok = QInputDialog.getText(self, &#34;æ·»åŠ å…³é”®å­—&#34;, &#34;è¾“å…¥å…³é”®å­—:&#34;)
        if ok and keyword:
            color = QColorDialog.getColor(Qt.GlobalColor.yellow, self, &#34;é€‰æ‹©é«˜äº®é¢œè‰²&#34;)
            if color.isValid():
                self.config[keyword] = color
                self.populate_table()

    def edit_keyword(self):
        selected_rows = self.table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self, &#34;è­¦å‘Š&#34;, &#34;è¯·å…ˆé€‰æ‹©è¦ç¼–è¾‘çš„è¡Œã€‚&#34;)
            return

        row         = selected_rows[0].row()
        old_keyword = self.table.item(row, 0).text()
        old_color   = self.config[old_keyword]

        new_keyword, ok = QInputDialog.getText(self, &#34;ç¼–è¾‘å…³é”®å­—&#34;, &#34;è¾“å…¥æ–°å…³é”®å­—:&#34;, QLineEdit.EchoMode.Normal, old_keyword)
        if not ok or not new_keyword:
            return 

        new_color = QColorDialog.getColor(old_color, self, &#34;é€‰æ‹©æ–°çš„é«˜äº®é¢œè‰²&#34;)
        if not new_color.isValid():
            return 

        if old_keyword != new_keyword:
            del self.config[old_keyword]
        self.config[new_keyword] = new_color
        self.populate_table()

    def remove_keyword(self):
        selected_rows = self.table.selectionModel().selectedRows()
        if not selected_rows:
            QMessageBox.warning(self, &#34;è­¦å‘Š&#34;, &#34;è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„è¡Œã€‚&#34;)
            return

        row = selected_rows[0].row()
        keyword = self.table.item(row, 0).text()

        reply = QMessageBox.question(self, &#34;ç¡®è®¤åˆ é™¤&#34;, f&#34;ç¡®å®šè¦åˆ é™¤å…³é”®å­— &#39;{keyword}&#39; å—ï¼Ÿ&#34;,
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                     QMessageBox.StandardButton.No)

        if reply == QMessageBox.StandardButton.Yes:
            del self.config[keyword]
            self.populate_table()

    def get_config(self):
        return self.config</code></pre>
</details>
<div class="desc"><p>é…ç½®é«˜äº®å…³é”®å­—å’Œé¢œè‰²çš„å¯¹è¯æ¡†</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtWidgets.QDialog</li>
<li>PyQt6.QtWidgets.QWidget</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.QtGui.QPaintDevice</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.HighlightConfigDialog.add_keyword"><code class="name flex">
<span>def <span class="ident">add_keyword</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_keyword(self):
    keyword, ok = QInputDialog.getText(self, &#34;æ·»åŠ å…³é”®å­—&#34;, &#34;è¾“å…¥å…³é”®å­—:&#34;)
    if ok and keyword:
        color = QColorDialog.getColor(Qt.GlobalColor.yellow, self, &#34;é€‰æ‹©é«˜äº®é¢œè‰²&#34;)
        if color.isValid():
            self.config[keyword] = color
            self.populate_table()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.HighlightConfigDialog.edit_keyword"><code class="name flex">
<span>def <span class="ident">edit_keyword</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def edit_keyword(self):
    selected_rows = self.table.selectionModel().selectedRows()
    if not selected_rows:
        QMessageBox.warning(self, &#34;è­¦å‘Š&#34;, &#34;è¯·å…ˆé€‰æ‹©è¦ç¼–è¾‘çš„è¡Œã€‚&#34;)
        return

    row         = selected_rows[0].row()
    old_keyword = self.table.item(row, 0).text()
    old_color   = self.config[old_keyword]

    new_keyword, ok = QInputDialog.getText(self, &#34;ç¼–è¾‘å…³é”®å­—&#34;, &#34;è¾“å…¥æ–°å…³é”®å­—:&#34;, QLineEdit.EchoMode.Normal, old_keyword)
    if not ok or not new_keyword:
        return 

    new_color = QColorDialog.getColor(old_color, self, &#34;é€‰æ‹©æ–°çš„é«˜äº®é¢œè‰²&#34;)
    if not new_color.isValid():
        return 

    if old_keyword != new_keyword:
        del self.config[old_keyword]
    self.config[new_keyword] = new_color
    self.populate_table()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.HighlightConfigDialog.get_config"><code class="name flex">
<span>def <span class="ident">get_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_config(self):
    return self.config</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.HighlightConfigDialog.populate_table"><code class="name flex">
<span>def <span class="ident">populate_table</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def populate_table(self):
    &#34;&#34;&#34;ç”¨å½“å‰é…ç½®å¡«å……è¡¨æ ¼&#34;&#34;&#34;
    self.table.setRowCount(0) # æ¸…ç©ºè¡¨æ ¼
    for keyword, color in self.config.items():
        row_position = self.table.rowCount()
        self.table.insertRow(row_position)

        # å…³é”®å­—
        self.table.setItem(row_position, 0, QTableWidgetItem(keyword))

        color_label = QLabel()
        color_label.setStyleSheet(f&#34;background-color: {color.name()}; border: 1px solid #555;&#34;) # ç›´æ¥è®¾ç½®èƒŒæ™¯è‰²å’Œè¾¹æ¡†
        self.table.setCellWidget(row_position, 1, color_label)

        # é¢œè‰²å€¼
        hex_color = color.name().upper()
        self.table.setItem(row_position, 2, QTableWidgetItem(hex_color))</code></pre>
</details>
<div class="desc"><p>ç”¨å½“å‰é…ç½®å¡«å……è¡¨æ ¼</p></div>
</dd>
<dt id="UWBDash.HighlightConfigDialog.remove_keyword"><code class="name flex">
<span>def <span class="ident">remove_keyword</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_keyword(self):
    selected_rows = self.table.selectionModel().selectedRows()
    if not selected_rows:
        QMessageBox.warning(self, &#34;è­¦å‘Š&#34;, &#34;è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„è¡Œã€‚&#34;)
        return

    row = selected_rows[0].row()
    keyword = self.table.item(row, 0).text()

    reply = QMessageBox.question(self, &#34;ç¡®è®¤åˆ é™¤&#34;, f&#34;ç¡®å®šè¦åˆ é™¤å…³é”®å­— &#39;{keyword}&#39; å—ï¼Ÿ&#34;,
                                 QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                                 QMessageBox.StandardButton.No)

    if reply == QMessageBox.StandardButton.Yes:
        del self.config[keyword]
        self.populate_table()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.LogWorker"><code class="flex name class">
<span>class <span class="ident">LogWorker</span></span>
<span>(</span><span>logger)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LogWorker(QThread):
    def __init__(self, logger):
        super().__init__()
        self.logger    = logger
        self.log_queue = queue.Queue()
        
    def add_log_task(self, log_type, level, message):
        self.log_queue.put((&#34;log&#34;, log_type, level, message))
        
    def run(self):
        while True:
            try:
                task = self.log_queue.get(timeout=1)
                if task[0] == &#34;log&#34;:
                    _, log_type, level, message = task
                    self.logger.log_to(log_type, level, message)
            except queue.Empty:
                continue
            except Exception as e:
                print(f&#34;Log thread error: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"><p>QThread(parent: Optional[QObject] = None)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtCore.QThread</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.LogWorker.add_log_task"><code class="name flex">
<span>def <span class="ident">add_log_task</span></span>(<span>self, log_type, level, message)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_log_task(self, log_type, level, message):
    self.log_queue.put((&#34;log&#34;, log_type, level, message))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.LogWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    while True:
        try:
            task = self.log_queue.get(timeout=1)
            if task[0] == &#34;log&#34;:
                _, log_type, level, message = task
                self.logger.log_to(log_type, level, message)
        except queue.Empty:
            continue
        except Exception as e:
            print(f&#34;Log thread error: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"><p>run(self)</p></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.MainWindow"><code class="flex name class">
<span>class <span class="ident">MainWindow</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MainWindow(QMainWindow):
    &#34;&#34;&#34;
    UWBDash ä¸»çª—å£ç±»
    
    è¿™æ˜¯ä¸€ä¸ªåŸºäº PyQt6 çš„ UWB æ•°æ®å¯è§†åŒ–å·¥å…·ã€‚ä¸»è¦åŠŸèƒ½åŒ…æ‹¬:
    - åŒä¸²å£æ•°æ®æ¥æ”¶å’Œæ˜¾ç¤º
    - UWB æ•°æ®å®æ—¶å›¾è¡¨å±•ç¤º
    - è‡ªå®šä¹‰ä¸»é¢˜åˆ‡æ¢
    - æ—¥å¿—è®°å½•åŠŸèƒ½
    &#34;&#34;&#34;
    theme_changed = pyqtSignal()

    def __init__(self):
        &#34;&#34;&#34;
        åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢
            
        åˆ›å»ºå¹¶è®¾ç½®:
        - æ ‡é¢˜æ 
        - å¯¼èˆªæ 
        - ä¸»å†…å®¹åŒºåŸŸ
        - ä¸»é¢˜æ ·å¼
        &#34;&#34;&#34;
        super().__init__()
        icon_path = Path(__file__).parent / &#34;logo.ico&#34;
        app_path  = Path(os.getcwd())
        print(f&#34;app_path: {app_path}&#34;)
        self.setWindowIcon(QIcon(str(icon_path)))  
        self.current_theme               = ThemeManager.DARK_THEME
        self.config_path                 = Path(__file__).parent / &#34;config.json&#34;
        self._load_background_config()
        self.logger                      = Logger(app_path=str(app_path))
        self.csv_title                   = [&#39;Master&#39;, &#39;Slave&#39;, &#39;NLOS&#39;, &#39;RSSI&#39;, &#39;Speed&#39;,&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;Auth&#39;, &#39;Trans&#39;]
        self.highlight_config_path       = str(Path(__file__).parent / &#34;highlight_config.json&#34;)
        self.highlight_config            = self.load_highlight_config()
        self.background_cache            = None         # æ·»åŠ èƒŒæ™¯ç¼“å­˜
        self.last_window_size            = QSize()      # æ·»åŠ çª—å£å°ºå¯¸è®°å½•
        self.drag_pos                    = QPoint()
        self.data_bits                   = 8
        self.parity                      = &#39;N&#39;          # N-æ— æ ¡éªŒ
        self.stop_bits                   = 1
        self.current_csv_log_file_path   = None
        self.current_text_log_file_path  = None
        self.current_text_log_file_path2 = None
        self.current_ports               = []
        self.current_ports2              = []
        self.data_buffer                 = []
        self.data_buffer2                = []
        

        self.display_timer = QTimer()
        self.display_timer.timeout.connect(self.update_display)

    
        self.display_timer.start(250)

        self.display_timer2 = QTimer() 
        self.display_timer2.timeout.connect(self.update_display2) 
        self.display_timer2.start(250)

        self.log_worker = LogWorker(self.logger)
        self.log_worker.start()

        self.chart_thread = ChartUpdateThread()
        self.chart_thread.update_chart.connect(self.update_chart)
        self.chart_thread.start()

        self.highlight_config_timer = QTimer()
        self.highlight_config_timer.timeout.connect(self.reload_highlight_config)
        self.highlight_config_timer.start(10000) 

        
        self.uwb_data = {
            &#39;master&#39;   : [],
            &#39;slave&#39;    : [],
            &#39;nlos&#39;     : [],
            &#39;lift_deep&#39;: [],
            &#39;speed&#39;    : [],
        }

        self.base_points = [
            (0, -40), (0, 0), (1, 10), (0, 10), (-1, 10),
            (1, 60), (0, 60), (-1, 60), (1, 110), (0, 110),
            (-1, 110), (1, 160), (0, 160), (-1, 160), (0, 210)
        ]

        self.setWindowFlags(
            Qt.WindowType.FramelessWindowHint |         # æ— è¾¹æ¡†
            Qt.WindowType.WindowMinimizeButtonHint |    # å…è®¸æœ€å°åŒ–
            Qt.WindowType.WindowMaximizeButtonHint      # å…è®¸æœ€å¤§åŒ–
        )
        self.init_ui()

    
    def paintEvent(self, event):
        if not self.background_cache or self.size() != self.last_window_size:
            size = self.size()
            background_path = Path(__file__).parent / self.background_image
            if not background_path.exists(): # Fallback if current image is somehow invalid
                print(f&#34;Warning: Background image {self.background_image} not found. Falling back to default.&#34;)
                if self.background_images:
                    self.background_image = self.background_images[0]
                    self._save_background_config() # Save the fallback
                    background_path = Path(__file__).parent / self.background_image
                else: # Ultimate fallback if list is also empty (should not happen with proper config loading)
                    # You might want to handle this case more gracefully, e.g., by not drawing a background
                    # or using a solid color. For now, let&#39;s assume config loading ensures a valid image.
                    print(&#34;Error: No background images available.&#34;)
                    return # Or handle error appropriately

            background = QPixmap(str(background_path))
            self.background_cache = background.scaled(
                size, 
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self.last_window_size = size
            
        painter = QPainter(self) 
        painter.setOpacity(1)
        x = (self.width() - self.background_cache.width()) // 2
        y = (self.height() - self.background_cache.height()) // 2
        painter.drawPixmap(x, y, self.background_cache)
    
    def _load_background_config(self):
        default_images = [
            &#34;pic/person1.jpg&#34;, &#34;pic/city1.jpg&#34;, &#34;pic/carton1.jpg&#34;,
            &#34;pic/landscape1.jpg&#34;, &#34;pic/person2.jpg&#34;, &#34;pic/landscape2.jpg&#34;
        ]
        default_current_image = default_images[0] if default_images else None

        try:
            if self.config_path.exists():
                with open(self.config_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
                    config_data = json.load(f) 
                self.background_images = config_data.get(&#34;background_images&#34;, default_images)
                self.background_image = config_data.get(&#34;current_background_image&#34;, default_current_image)
                if not self.background_images: # Ensure list is not empty
                    self.background_images = default_images
                if self.background_image not in self.background_images and self.background_images:
                    self.background_image = self.background_images[0]
                elif not self.background_images:
                     self.background_image = None # No images available

                # Ensure current_background_image is valid and exists in the list
                if self.background_image not in self.background_images:
                    self.background_image = self.background_images[0] if self.background_images else default_current_image
                
                # Initialize background_image_index based on the loaded current_background_image
                if self.background_image and self.background_image in self.background_images:
                    self.background_image_index = self.background_images.index(self.background_image)
                else:
                    self.background_image_index = 0 # Default to first image if current is invalid or not found
                    if self.background_images: # If there are images, set current to the first one
                        self.background_image = self.background_images[0]
                    else: # If no images at all, set current to None
                        self.background_image = None

            else:
                self.background_images = default_images
                self.background_image = default_current_image
                self.background_image_index = 0
                self._save_background_config() # Create config file with defaults
        except Exception as e:
            print(f&#34;Error loading background config: {e}. Using defaults.&#34;)
            self.background_images = default_images
            self.background_image = default_current_image
            self.background_image_index = 0
            # Attempt to save defaults if loading failed, to fix a potentially corrupt file
            self._save_background_config()
        
        # Final check to ensure background_image is set if list is not empty
        if not self.background_image and self.background_images:
            self.background_image = self.background_images[0]
            self.background_image_index = 0

    def _save_background_config(self):
        config_data = {
            &#34;background_images&#34;: self.background_images,
            &#34;current_background_image&#34;: self.background_image
        }
        try:
            with open(self.config_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
                json.dump(config_data, f, indent=2)
        except Exception as e:
            print(f&#34;Error saving background config: {e}&#34;)
    
    def load_highlight_config(self):
        try:
            with open(self.highlight_config_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
                data = json.load(f)
            # å°†é¢œè‰²å­—ç¬¦ä¸²è½¬ä¸º QColor
            return {k: QColor(v) for k, v in data.items()}
        except Exception as e:
            print(f&#34;åŠ è½½é«˜äº®é…ç½®å¤±è´¥: {e}&#34;)
            # é»˜è®¤é…ç½®
            return {
                &#34;APP     :ERROR&#34;     : QColor(&#34;#ff7f7f&#34;),
                &#34;APP     :INFO&#34;      : QColor(&#34;#8ccfff&#34;),
                &#34;APP     :WARN&#34;      : QColor(&#34;#ffd280&#34;),
                &#34;gCapSessionHandle&#34;  : QColor(&#34;#00ff7f&#34;),
                &#34;gDtxSessionHandle&#34;  : QColor(&#34;#b9f309&#34;),
                &#34;gMrmSessionHandle&#34;  : QColor(&#34;#ffaaff&#34;),
                &#34;AuthenticationState&#34;: QColor(&#34;#3daaea&#34;),
                &#34;APP_HIFTask&#34;        : QColor(&#34;#34a7b2&#34;),
            }

    def reload_highlight_config(self):
        # å°†å½“å‰çš„ self.highlight_config å†™å›åˆ° JSON æ–‡ä»¶
        try:
            data = {k: v.name() for k, v in self.highlight_config.items()}
            with open(self.highlight_config_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
                json.dump(data, f, ensure_ascii=False, indent=4)
        except Exception as e:
            print(f&#34;ä¿å­˜é«˜äº®é…ç½®å¤±è´¥: {e}&#34;)

    def init_ui(self):
        title_bar = self.create_title_bar()
        self.setGeometry(100, 100, 800, 700)

        main_widget = QWidget()
        self.setCentralWidget(main_widget)
        main_layout = QVBoxLayout(main_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        nav_container = self.create_nav_bar()
        self.nav_list.currentRowChanged.connect(self.switch_page)

        self.stacked_widget = QStackedWidget()
        self.create_pages()

        splitter = QSplitter(Qt.Orientation.Horizontal)
        splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background: transparent;
                border    : none;
                min-height: 2px;
            }
            QSplitter::handle:vertical {
                height: 2px;
            }
            QSplitter::handle:horizontal {
                width: 2px;
            }
        &#34;&#34;&#34;)
        
        splitter.addWidget(nav_container)
        splitter.addWidget(self.stacked_widget)
        splitter.setStretchFactor(1, 1)  
        splitter.setSizes([80,500])

        main_layout.addWidget(title_bar)
        main_layout.addWidget(splitter)  
        
        self.apply_theme()
        self.nav_list.setCurrentRow(0)

    def create_nav_bar(self):
        nav_container = QWidget()
        nav_container.setMinimumWidth(65)  
        nav_container.setMaximumWidth(300) 
        nav_layout = QVBoxLayout(nav_container)
        nav_layout.setContentsMargins(0, 0, 0, 0)
        nav_layout.setSpacing(0)

        self.nav_list = QListWidget()
        self.nav_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        self.nav_list.setFocusPolicy(Qt.FocusPolicy.NoFocus)
        
        nav_items = [&#34;COM 1&#34;, &#34;COM 2&#34;, &#34;CHART&#34;] 
        for item in nav_items:
            list_item = QListWidgetItem(item)
            list_item.setFont(QFont(&#34;Segoe UI&#34;, 10, QFont.Weight.Bold))
            list_item.setSizeHint(QSize(65, 50))
            list_item.setTextAlignment(Qt.AlignmentFlag.AlignVCenter)
            self.nav_list.addItem(list_item)

        self.theme_btn = QPushButton(&#34; ğŸŒ“ &#34;)
        # self.theme_btn.setFixedHeight(45)
        self.theme_btn.setStyleSheet(f&#34;background: {self.current_theme[&#39;bg&#39;]}; border-radius: 0px;&#34;)
        self.theme_btn.clicked.connect(self.toggle_theme)

        nav_layout.addWidget(self.nav_list)
        nav_layout.addWidget(self.theme_btn)
        return nav_container
    
    def mousePressEvent(self, event):
        idx = self.stacked_widget.currentIndex()
        count = self.stacked_widget.count()
        print(f&#34;count: {count} idx: {idx}&#34;)
        if event.button() == Qt.MouseButton.XButton2:  
            new_idx = (idx - 1) % count
            self.stacked_widget.setCurrentIndex(new_idx)
            self.nav_list.setCurrentRow(new_idx)
            print(f&#34;New_idx: {new_idx}&#34;)
        elif event.button() == Qt.MouseButton.XButton1:  
            new_idx = (idx + 1) % count
            self.stacked_widget.setCurrentIndex(new_idx)
            self.nav_list.setCurrentRow(new_idx)
            print(f&#34;New_idx: {new_idx}&#34;)
        else:
            super().mousePressEvent(event)
    
    def wheelEvent(self, event):
        current_idx = self.stacked_widget.currentIndex()
        # æ£€æµ‹æ»šè½®æ–¹å‘ï¼ˆæ­£å€¼è¡¨ç¤ºå‘ä¸Šæ»šåŠ¨ï¼‰
        delta = event.angleDelta().y()
        
        if current_idx == 0:  # COM 1 é¡µé¢
            if delta &gt; 0:  # å‘ä¸Šæ»šåŠ¨
                self.auto_scroll.setChecked(True)  
            elif delta &lt; 0 and not self.auto_scroll.isChecked():  # å‘ä¸‹æ»šåŠ¨ä¸”è‡ªåŠ¨æ»šåŠ¨æœªå¯ç”¨
                # å¯é€‰ï¼šåœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å‘ä¸‹æ»šåŠ¨é€»è¾‘
                pass
        elif current_idx == 1:  # COM 2 é¡µé¢
            if delta &gt; 0:  # å‘ä¸Šæ»šåŠ¨
                self.auto_scroll2.setChecked(True)  
            elif delta &lt; 0 and not self.auto_scroll2.isChecked():  # å‘ä¸‹æ»šåŠ¨ä¸”è‡ªåŠ¨æ»šåŠ¨æœªå¯ç”¨
                # å¯é€‰ï¼šåœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å‘ä¸‹æ»šåŠ¨é€»è¾‘
                pass
                
        # è°ƒç”¨çˆ¶ç±»æ–¹æ³•ä»¥ä¿æŒæ­£å¸¸çš„æ»šåŠ¨è¡Œä¸º
        super().wheelEvent(event)

    def eventFilter(self, obj, event):
        if (obj == self.serial_display or obj == self.serial_display2) and event.type() == QEvent.Type.Wheel:
            print(f&#34;Event type: {event.type()}&#34;)
            self.wheelEvent(event)
            return True # é˜»æ­¢äº‹ä»¶è¿›ä¸€æ­¥ä¼ æ’­
        return super().eventFilter(obj, event)

    def create_title_bar(self):
        title_bar = QWidget()
        title_bar.setObjectName(&#34;titleBar&#34;)
        title_bar.setFixedHeight(30)
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(10, 0, 10, 0)
        title_layout.setSpacing(5)

        def mousePressEvent(event):
            if event.button() == Qt.MouseButton.LeftButton:
                self.drag_pos = event.globalPosition().toPoint()
        
        def mouseMoveEvent(event):
            if event.buttons() &amp; Qt.MouseButton.LeftButton:
                self.move(self.pos() + event.globalPosition().toPoint() - self.drag_pos)
                self.drag_pos = event.globalPosition().toPoint()
        
        # å°†äº‹ä»¶å¤„ç†å™¨ç»‘å®šåˆ°æ ‡é¢˜æ 
        title_bar.mousePressEvent = mousePressEvent
        title_bar.mouseMoveEvent  = mouseMoveEvent

        title_bar.setAttribute(Qt.WidgetAttribute.WA_MouseTracking)
        
        self.title_label = QLabel(&#34;UWBDash&#34;)
        self.title_label.setObjectName(&#34;titleLabel&#34;)
        
        help_btn = QPushButton(&#34;Help&#34;)
        help_btn.setStyleSheet(&#34;background: transparent; border: none;color:#c29500;font-weight:bold;&#34;)
        help_btn.clicked.connect(self.show_help_dialog)
        
        about_btn = QPushButton(&#34;About&#34;)
        about_btn.setStyleSheet(&#34;background: transparent; border: none;color:#c29500;font-weight:bold;&#34;)
        about_btn.clicked.connect(self.show_about_dialog)

        btn_size = QSize(20, 20)
        
        minimize_btn = QPushButton(&#34;â”€&#34;)
        minimize_btn.setFixedSize(btn_size)
        minimize_btn.clicked.connect(self.showMinimized)
        
        self.maximize_btn = QPushButton(&#34;â–¡&#34;)
        self.maximize_btn.setFixedSize(btn_size)
        self.maximize_btn.clicked.connect(self.toggle_maximize)
        
        close_btn = QPushButton(&#34;âŒ&#34;)
        close_btn.setFixedSize(btn_size)
        close_btn.clicked.connect(self.close)

        control_btns = [minimize_btn, self.maximize_btn, close_btn]
        for btn in control_btns:
            btn.setStyleSheet(&#34;&#34;&#34;
                QPushButton {
                    border    : none;
                    font-size : 10px;
                    padding   : 5px;
                    background: transparent;
                }
                QPushButton:hover {
                    background-color: rgba(255, 255, 255, 0.1);
                }
            &#34;&#34;&#34;)
        close_btn.setStyleSheet(close_btn.styleSheet() + &#34;&#34;&#34;
            QPushButton:hover {
                background-color: #ff4444;
            }
        &#34;&#34;&#34;)

        title_layout.addWidget(self.title_label)
        title_layout.addWidget(help_btn)
        title_layout.addWidget(about_btn)
        title_layout.addStretch()
        title_layout.addWidget(minimize_btn)
        title_layout.addWidget(self.maximize_btn)
        title_layout.addWidget(close_btn)
        
        return title_bar
    
    def show_help_dialog(self):
        help_dialog = QDialog(self)
        help_dialog.setWindowTitle(&#34;UWBDash Help&#34;)
        help_dialog.setFixedSize(500, 400)

        layout = QVBoxLayout(help_dialog)

        title_label = QLabel(&#34;UWBDash Help Guide&#34;)
        title_label.setStyleSheet(&#34;font-size: 24px; font-weight: bold; color: #c29500;&#34;)
        title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

        # Create a scroll area for the content
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)

        # Add help sections
        sections = [
            (&#34;Basic Controls&#34;, [
                &#34;â€¢ Click and drag the title bar to move the window&#34;,
                &#34;â€¢ Ctrl + F to open the search box&#34;,
                &#34;â€¢ Select the message box and press Space to stop the scrolling&#34;
            ]),
            (&#34;Data Visualization&#34;, [
                &#34;â€¢ Slave anchor needs to be connected for transmitting json data&#34;,
                &#34;â€¢ Real-time UWB positioning data display&#34;,
                &#34;â€¢ Interactive charts for key param monitoring&#34;,
            ]),
            (&#34;Configuration&#34;, [
                &#34;â€¢ Set up serial port parameters in the settings panel&#34;,
                &#34;â€¢ Customize highlight colors for different message types&#34;
            ]),
            (&#34;Logging&#34;, [
                &#34;â€¢ A log file will be created automatically in the app directory when the &#39;æ‰“å¼€ä¸²å£&#39; button is clicked every time&#34;,
            ])
        ]

        for section_title, items in sections:
            section_label = QLabel(section_title)
            section_label.setStyleSheet(&#34;font-size: 16px; font-weight: bold; color: #666; margin-top: 10px;&#34;)
            scroll_layout.addWidget(section_label)

            for item in items:
                item_label = QLabel(item)
                # item_label.setStyleSheet(&#34;font-size: 12px; color: #333; margin-left: 20px;&#34;)
                item_label.setWordWrap(True)
                scroll_layout.addWidget(item_label)

        scroll_layout.addStretch()
        scroll.setWidget(scroll_content)
        layout.addWidget(title_label)
        layout.addWidget(scroll)

        # Add OK button
        ok_button = QPushButton(&#34;OK&#34;)
        ok_button.clicked.connect(help_dialog.accept)
        layout.addWidget(ok_button)
        help_dialog.exec()

    def show_about_dialog(self):
        QMessageBox.about(self, &#34;å…³äº&#34;, &#34;UWBDash APP\nCardShare@QLL&#34;)
    
    def open_highlight_config_dialog(self):
        dialog = HighlightConfigDialog(self.highlight_config, self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            self.highlight_config = dialog.get_config()


    def toggle_maximize(self):
        if self.isMaximized():
            self.showNormal()
            self.maximize_btn.setText(&#34;â–¡&#34;)
        else:
            self.showMaximized()
            self.maximize_btn.setText(&#34;â&#34;)

    def create_pages(self):
        COM1_page  = self.create_COM_page()
        COM2_page  = self.create_COM_page2()
        Chart_page = self.create_Chart_page()

        self.stacked_widget.addWidget(COM1_page)
        self.stacked_widget.addWidget(COM2_page)
        self.stacked_widget.addWidget(Chart_page)
    
    def create_COM_page2(self):
        COM2_page = QWidget()
        layout = QVBoxLayout(COM2_page)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        top_widget = QWidget()
        top_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.2);&#34;)
        top_layout = QHBoxLayout(top_widget)
        top_layout.setContentsMargins(5, 5, 5, 5)
        
        self.port_combo2 = QComboBox()
        self.port_combo2.setMinimumWidth(120)

        self.baud_combo2 = QComboBox()
        self.baud_combo2.addItems([&#39;9600&#39;, &#39;115200&#39;, &#39;230400&#39;, &#39;460800&#39;, &#39;3000000&#39;])
        self.baud_combo2.setCurrentText(&#39;3000000&#39;)
        self.baud_combo2.setStyleSheet(self.port_combo2.styleSheet())

        status_widget = QWidget()
        status_layout = QHBoxLayout(status_widget)
        status_layout.setContentsMargins(10, 0, 10, 0)
        status_layout.setSpacing(5)
        self.status_indicator2 = QLabel(&#34;â—&#34;)
        self.status_indicator2.setStyleSheet(&#34;color: red; font-size: 16px;background:rgba(36, 42, 56, 0);&#34;)
        status_layout.addWidget(self.status_indicator2)

        self.toggle_btn2 = QPushButton(&#34;æ‰“å¼€ä¸²å£&#34;)
        self.toggle_btn2.setFixedWidth(90)
        self.toggle_btn2.clicked.connect(self.toggle_port2)

        line_top_1 = QFrame()
        line_top_1.setFrameShape(QFrame.Shape.VLine)
        line_top_1.setFrameShadow(QFrame.Shadow.Sunken)
        line_top_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)
        
        max_lines_label = QLabel(&#34;æœ€å¤§è¡Œæ•°&#34;)
        max_lines_label.setStyleSheet(&#34;background: rgba(36, 42, 56, 0);&#34;)
        self.max_lines_spin2 = QSpinBox()
        self.max_lines_spin2.setRange(50000, 300000)
        self.max_lines_spin2.setValue(150000)
        self.max_lines_spin2.setSingleStep(10000)
        self.max_lines_spin2.valueChanged.connect(self.update_max_lines2)
        self.current_lines_label2 = QLabel(&#34;å½“å‰è¡Œæ•°: 0&#34;)
        self.current_lines_label2.setStyleSheet(&#34;background: rgba(36, 42, 56, 0);&#34;)
        
        line_top_2 = QFrame()
        line_top_2.setFrameShape(QFrame.Shape.VLine)
        line_top_2.setFrameShadow(QFrame.Shadow.Sunken)
        line_top_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

        self.Address_label_2 = QLabel(&#34;0000  -&#34;)
        self.Address_label_2.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
       
        self.Transaction_time_label_2 = QLabel(&#34;0000ms&#34;)
        self.Transaction_time_label_2.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
        
        top_layout.addWidget(self.port_combo2)
        top_layout.addSpacing(10)
        top_layout.addWidget(self.baud_combo2)
        top_layout.addSpacing(10)
        top_layout.addWidget(status_widget)
        top_layout.addWidget(self.toggle_btn2)
        top_layout.addSpacing(20)
        top_layout.addWidget(line_top_1)
        top_layout.addSpacing(20)
        top_layout.addWidget(max_lines_label)
        top_layout.addWidget(self.max_lines_spin2)
        top_layout.addSpacing(10)
        top_layout.addWidget(self.current_lines_label2)
        top_layout.addSpacing(20)
        top_layout.addWidget(line_top_2)
        top_layout.addSpacing(20)
        top_layout.addWidget(self.Address_label_2)
        top_layout.addSpacing(5)
        top_layout.addWidget(self.Transaction_time_label_2)
        top_layout.addStretch()

        layout.addWidget(top_widget)

        splitter = QSplitter(Qt.Orientation.Vertical)
        splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background: transparent;
                border    : none;
                min-height: 5px;
            }
            QSplitter::handle:vertical {
                height: 5px;
            }
            QSplitter::handle:horizontal {
                width: 5px;
            }
        &#34;&#34;&#34;)
        
        self.create_display_area2(splitter)
    
        bottom_widget = QWidget()
        # bottom_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.8);&#34;)
        bottom_layout = QHBoxLayout(bottom_widget)
        
        self.clear_btn2 = QPushButton(&#34;æ¸…å±&#34;)
        self.clear_btn2.setFixedWidth(80)
        self.clear_btn2.clicked.connect(self.serial_display2.clear)

        self.config_highlight_btn2 = QPushButton(&#34;é«˜äº®&#34;)
        self.config_highlight_btn2.setFixedWidth(80)
        self.config_highlight_btn2.clicked.connect(self.open_highlight_config_dialog)

        self.timestamp2 = QCheckBox(&#34;ğŸ•’ æ—¶é—´æˆ³&#34;)
        self.timestamp2.setObjectName(&#34;timestamp&#34;)
        self.timestamp2.setToolTip(&#34;æ¯è¡Œå‰æ·»åŠ æ—¶é—´æˆ³&#34;)
        self.timestamp2.setChecked(True)
        self.auto_scroll2 = QCheckBox(&#34;ğŸ“Œ è‡ªåŠ¨æ»šåŠ¨&#34;)
        self.auto_scroll2.setObjectName(&#34;autoScroll&#34;)
        self.auto_scroll2.setChecked(False)
        self.auto_scroll2.setToolTip(&#34;é”å®šæ»šåŠ¨æ¡åˆ°åº•éƒ¨&#34;)

        line_bottom_1 = QFrame()
        line_bottom_1.setFrameShape(QFrame.Shape.VLine)
        line_bottom_1.setFrameShadow(QFrame.Shadow.Sunken)
        line_bottom_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

        line_bottom_2 = QFrame()
        line_bottom_2.setFrameShape(QFrame.Shape.VLine)
        line_bottom_2.setFrameShadow(QFrame.Shadow.Sunken)
        line_bottom_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

        # æ—¥å¿—ç›¸å…³æŒ‰é’®
        self.open_text_log_file_btn2 = QPushButton(&#34;ğŸ“„TEXT&#34;)
        self.open_text_log_file_btn2.setFixedWidth(75)
        self.open_text_log_file_btn2.setToolTip(&#34;æ‰“å¼€å½“å‰Textæ—¥å¿—æ–‡ä»¶&#34;)
        self.open_text_log_file_btn2.clicked.connect(self.open_current_text_log_file2)
        self.open_text_log_file_btn2.setEnabled(False)

        self.open_log_folder_btn2 = QPushButton(&#34;ğŸ“&#34;)
        self.open_log_folder_btn2.setFixedWidth(60)
        self.open_log_folder_btn2.setToolTip(&#34;æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹&#34;)
        self.open_log_folder_btn2.clicked.connect(self.open_log_folder)

        bottom_layout.addWidget(self.clear_btn2)
        bottom_layout.addWidget(self.config_highlight_btn2)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(line_bottom_1)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(self.timestamp2)
        bottom_layout.addWidget(self.auto_scroll2)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(line_bottom_2)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(self.open_text_log_file_btn2)
        bottom_layout.addWidget(self.open_log_folder_btn2)
        bottom_layout.addStretch()
        
        splitter.addWidget(bottom_widget)
        splitter.setSizes([2000, 100])  
        
        layout.addWidget(splitter)
        
        self.port_scan_timer2 = QTimer()
        self.port_scan_timer2.timeout.connect(self.refresh_ports2)
        self.port_scan_timer2.start(1000)
        self.refresh_ports2()
        
        return COM2_page
    
    def update_max_lines2(self, value):
        self.serial_display2.document().setMaximumBlockCount(value)
    
    def update_current_lines2(self):
        current_count = self.serial_display2.document().blockCount()
        self.current_lines_label2.setText(f&#34;å½“å‰è¡Œæ•°: {current_count}&#34;)
        max_lines = self.serial_display2.document().maximumBlockCount()
        if current_count &gt;= max_lines:
            self.serial_display2.clear()

    def create_display_area2(self, layout):
        self.serial_display2 = QTextEdit()
        self.serial_display2.setReadOnly(True)
        self.serial_display2.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ç¡®ä¿èƒ½æ¥æ”¶é”®ç›˜äº‹ä»¶
        self.serial_display2.installEventFilter(self) # å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨
        self.serial_display2.document().setMaximumBlockCount(150000)  # é™åˆ¶æœ€å¤§è¡Œæ•°
        self.serial_display2.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)  # è‡ªåŠ¨æ¢è¡Œ
        self.serial_display2.setWordWrapMode(QTextOption.WrapMode.WrapAnywhere)  # å…è®¸åœ¨ä»»ä½•ä½ç½®æ¢è¡Œ
        
        self.serial_display2.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.serial_display2.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.serial_display2.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        
        font = QFont(&#34;Microsoft YaHei&#34;, 12)
        self.serial_display2.setFont(font)
        
        self.serial_display2.setStyleSheet(&#34;&#34;&#34;
            QTextEdit {
                background-color          : rgba(36, 42, 56, 0.177);
                border                    : 1.5px solid #3a4a5c;
                border-radius             : 16px;
                padding                   : 12px;
                color                     : {theme[&#39;text&#39;]};
                font-size                 : 15px;
                font-family               : &#39;JetBrains Mono&#39;, &#39;Consolas&#39;, &#39;Microsoft YaHei&#39;, monospace;
                selection-background-color: #088bef;
                selection-color           : #ffffff;

            }
            QTextEdit:focus {
                border          : 1.5px solid #477faa;
                background-color: rgba(36, 42, 56, 0.5);
            }
            QScrollBar:vertical {
                background   : transparent;
                width        : 10px;
                margin       : 2px 0 2px 0;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical {
                background: qlineargradient(
                    x1:0, y1:0, x2:1, y2:1,
                    stop:0 #3da9fc, stop:1 #1e293b
                );
                min-height   : 24px;
                border-radius: 5px;
            }
            QScrollBar::handle:vertical:hover {
                background: qlineargradient(
                    x1:0, y1:0, x2:1, y2:1,
                    stop:0 #90caf9, stop:1 #3da9fc
                );
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height    : 0;
                background: none;
                border    : none;
            }
        &#34;&#34;&#34;)
        
        self.serial_display2.document().blockCountChanged.connect(self.update_current_lines2)
        self.update_current_lines2()

        self.find_dialog2 = QDialog(self)
        self.find_dialog2.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.find_dialog2.setFixedSize(300, 48)
        self.find_dialog2.setStyleSheet(&#34;&#34;&#34;
            QDialog {
                background-color: rgba(45, 52, 54, 0.95);
                border          : 1px solid rgba(255, 255, 255, 0.1);
                border-radius   : 10px;
            }
        &#34;&#34;&#34;)

        find_layout = QHBoxLayout(self.find_dialog2)
        find_layout.setContentsMargins(6, 6, 6, 6)
        find_layout.setSpacing(6)

        self.find_input2 = QLineEdit()
        self.find_input2.setPlaceholderText(&#34;è¾“å…¥æœç´¢å†…å®¹&#34;)
        self.find_input2.textChanged.connect(self.update_find_count2)
        self.count_label2 = QLabel(&#34;0/0&#34;)

        from PyQt6.QtWidgets import QToolButton
        self.prev_btn2 = QToolButton()
        self.prev_btn2.setArrowType(Qt.ArrowType.UpArrow)
        self.prev_btn2.clicked.connect(lambda: self.find_text2(False))
        self.next_btn2 = QToolButton()
        self.next_btn2.setArrowType(Qt.ArrowType.DownArrow)
        self.next_btn2.clicked.connect(lambda: self.find_text2(True))

        self.close_find_btn2 = QToolButton()
        self.close_find_btn2.setText(&#34;âœ•&#34;)
        self.close_find_btn2.clicked.connect(self.find_dialog2.close)
        self.close_find_btn2.setStyleSheet(&#34;font-size: 16px; color: #fff; background: transparent; border: none;&#34;)

        find_layout.addWidget(self.find_input2)
        find_layout.addWidget(self.count_label2)
        find_layout.addWidget(self.prev_btn2)
        find_layout.addWidget(self.next_btn2)
        find_layout.addWidget(self.close_find_btn2)

        self.serial_display2.keyPressEvent = self.on_display_key_press2
        # self.serial_display2.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
        
        layout.addWidget(self.serial_display2)
    
    
    def on_display_key_press2(self, event):
        if event.key() == Qt.Key.Key_Space:
            self.auto_scroll2.setChecked(not self.auto_scroll2.isChecked())
        elif event.modifiers() &amp; Qt.KeyboardModifier.ControlModifier:
            if event.key() == Qt.Key.Key_F:
                cursor = self.serial_display2.textCursor()
                selected_text = cursor.selectedText()
                self.show_find_dialog2()
                if selected_text:
                    self.find_input2.setText(selected_text)
                    self.find_input2.selectAll()
                event.accept()
                return
        
        QTextEdit.keyPressEvent(self.serial_display2, event)
    
    def show_find_dialog2(self):
        display_rect = self.serial_display2.rect()
        display_pos = self.serial_display2.mapToGlobal(display_rect.topRight())
        dialog_x = display_pos.x() - self.find_dialog2.width() - 10  # è·ç¦»å³è¾¹ç•Œ10åƒç´ 
        dialog_y = display_pos.y() + 10  # è·ç¦»é¡¶éƒ¨10åƒç´ 
        self.find_dialog2.move(dialog_x, dialog_y)
        
        self.find_dialog2.show()
        self.find_input2.setFocus()
        self.find_input2.selectAll()
        
    
    def update_find_count2(self):
        &#34;&#34;&#34;å¢é‡æ›´æ–°æŸ¥æ‰¾ç»“æœè®¡æ•°&#34;&#34;&#34;
        text    = self.find_input2.text()
        content = self.serial_display2.toPlainText()
        
        # å¢é‡ç¼“å­˜ï¼šåªå¯¹æ–°å¢å†…å®¹æŸ¥æ‰¾
        if not hasattr(self, &#39;_find_count_cache2&#39;):
            self._find_count_cache2 = {&#39;text&#39;: &#39;&#39;, &#39;content_len&#39;: 0, &#39;count&#39;: 0}
        cache = self._find_count_cache2

        if not text:
            self.count_label2.setText(&#34;0/0&#34;)
            cache[&#39;text&#39;]        = &#39;&#39;
            cache[&#39;content_len&#39;] = 0
            cache[&#39;count&#39;]       = 0
            return

        if text != cache[&#39;text&#39;]:
            count = content.count(text)
            cache[&#39;text&#39;]        = text
            cache[&#39;content_len&#39;] = len(content)
            cache[&#39;count&#39;]       = count
        else:
            old_len = cache[&#39;content_len&#39;]
            if len(content) &gt; old_len:
                new_part  = content[old_len:]
                count_new = new_part.count(text)
                cache[&#39;count&#39;]       += count_new
                cache[&#39;content_len&#39;]  = len(content)
            elif len(content) &lt; old_len:
                count                = content.count(text)
                cache[&#39;count&#39;]       = count
                cache[&#39;content_len&#39;] = len(content)

        count = cache[&#39;count&#39;]
        
        # è·å–å½“å‰é€‰ä¸­çš„ä½ç½®
        current = 0
        cursor  = self.serial_display2.textCursor()
        if cursor.hasSelection():
            sel_text = cursor.selectedText()
            if sel_text == text:
                pos     = cursor.position() - len(text)
                current = content[:pos].count(text) + 1
        
        self.count_label2.setText(f&#34;{current}/{count}&#34;)

    def find_text2(self, forward=True):
        &#34;&#34;&#34;å¢é‡æŸ¥æ‰¾æ–‡æœ¬&#34;&#34;&#34;
        text = self.find_input2.text()
        if not text:
            return
        
        # ç»ˆæ­¢ä¸Šä¸€ä¸ªæŸ¥æ‰¾çº¿ç¨‹
        if hasattr(self, &#39;find_thread2&#39;) and self.find_thread2.isRunning():
            self.find_thread2.terminate()
            self.find_thread2.wait()
        
        doc = self.serial_display2.document()
        current_format = doc.defaultTextOption()

        self.auto_scroll2.setChecked(True)

        content = self.serial_display2.toPlainText()
        cursor = self.serial_display2.textCursor()
        cur_pos = cursor.selectionStart() if cursor.hasSelection() else cursor.position()

        # å¯åŠ¨æŸ¥æ‰¾çº¿ç¨‹
        self.find_thread2 = FindThread(content, text, cur_pos, forward)
        self.find_thread2.result_ready.connect(self.on_find_result2)
        self.find_thread2.start()

    def on_find_result2(self, current, total, positions):
        # å®šä½å¹¶é«˜äº®å½“å‰åŒ¹é…é¡¹
        pos = positions[current]
        length = len(self.find_input2.text())
        cursor = self.serial_display2.textCursor()
        cursor.setPosition(pos)
        cursor.setPosition(pos + length, QTextCursor.MoveMode.KeepAnchor)
        self.serial_display2.setTextCursor(cursor)

        fmt = QTextCharFormat()
        fmt.setBackground(QColor(&#34;#ffaaff&#34;))
        fmt.setForeground(QColor(&#34;#000000&#34;))
        fmt.setFontWeight(QFont.Weight.Bold)
        cursor.mergeCharFormat(fmt)

        self._last_highlight2 = (pos, length)
        self.count_label2.setText(f&#34;{current+1}/{total}&#34;)
    
    def refresh_ports2(self):
        import serial.tools.list_ports
        current_port = self.port_combo2.currentText() if self.port_combo2.count() &gt; 0 else &#34;&#34;
        ports = list(serial.tools.list_ports.comports())
        available_ports = [port.device for port in ports]
        if set(available_ports) != set(self.current_ports2):
            self.port_combo2.clear()
            for port in ports:
                self.port_combo2.addItem(port.device)
            if current_port and self.port_combo2.findText(current_port) &gt;= 0:
                self.port_combo2.setCurrentText(current_port)
            self.current_ports2 = available_ports
    
    def toggle_port2(self):
        if self.toggle_btn2.text() == &#34;æ‰“å¼€ä¸²å£&#34;:
            try:
                port = self.port_combo2.currentText()
                if not port:
                    raise Exception(&#34;è¯·é€‰æ‹©ä¸²å£&#34;)
                    
                baud = int(self.baud_combo2.currentText())
                self.serial2 = serial.Serial(
                    port     = port,
                    baudrate = baud,
                    bytesize = self.data_bits,
                    parity   = self.parity,
                    stopbits = self.stop_bits,
                    timeout  = 0.1
                )
                
                if not self.serial2.is_open:
                    self.serial2.open()
                
                self.serial_thread2 = SerialReadThread(self.serial2)
                self.serial_thread2.data_received.connect(self.handle_serial_2_data)
                self.serial_thread2.start()
                
                self.toggle_btn2.setText(&#34;å…³é—­ä¸²å£&#34;)
                self.status_indicator2.setStyleSheet(&#34;color: green;background:rgba(36,36,36,0);&#34;)
                
                current_time      = datetime.datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
                port_name         = self.port_combo2.currentText().replace(&#34;:&#34;, &#34;_&#34;)
                text_log_filename = f&#34;[{port_name}] {current_time}.log&#34;

                # ç¡®ä¿ logger å®ä¾‹åŠå…¶ç›®å½•å±æ€§å­˜åœ¨
                if hasattr(self.logger, &#39;text_log_dir&#39;):
                    self.current_text_log_file_path2 = os.path.join(self.logger.text_log_dir, text_log_filename)
                    self.logger.create_logger(&#34;UwbLog2&#34;, text_log_filename, &#34;text&#34;) # åˆ›å»º Text æ—¥å¿—
                    self.open_text_log_file_btn2.setEnabled(True)
                else:
                    # å¦‚æœæ— æ³•è·å– log_dirï¼Œåˆ™ç¦ç”¨æŒ‰é’®å¹¶æ‰“å°è­¦å‘Š
                    print(&#34;è­¦å‘Š: Logger å¯¹è±¡ç¼ºå°‘ csv_log_dir æˆ– text_log_dir å±æ€§ï¼Œ&#39;æ‰“å¼€æ—¥å¿—æ–‡ä»¶&#39;åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚&#34;)
                    self.current_text_log_file_path2 = None
                
            except Exception as e:
                QMessageBox.warning(self, &#34;é”™è¯¯&#34;, f&#34;æ‰“å¼€ä¸²å£å¤±è´¥: {str(e)}&#34;)
        else:
            try:
                if hasattr(self, &#39;serial_thread2&#39;) and self.serial_thread2:
                    self.serial_thread2.stop()
                    self.serial_thread2 = None

                if hasattr(self, &#39;serial2&#39;) and self.serial2:
                    self.serial2.close()
                    self.serial2 = None
                
                self.toggle_btn2.setText(&#34;æ‰“å¼€ä¸²å£&#34;)
                self.status_indicator2.setStyleSheet(&#34;color: red;background:rgba(36,36,36,0);&#34;)
            except Exception as e:
                QMessageBox.warning(self, &#34;é”™è¯¯&#34;, f&#34;å…³é—­ä¸²å£å¤±è´¥: {str(e)}&#34;)
    
    def handle_serial_2_data(self, data):
        try:
            text = data.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)
            self.log_worker.add_log_task(&#34;UwbLog2&#34;, &#34;info&#34;, text.strip())
            text = re.sub(r&#39;\x1b\[[0-9;]*[a-zA-Z]&#39;, &#39;&#39;, text)

            if &#34;@@@ Time of Write Card End&#34; in text:
                #&#34;@@@ Time of Write Card End     = 00:14:520  â”‚ 80D7 â”‚  710 ms&#34;
                match = re.search(r&#34;â”‚\s*([0-9A-Fa-f]+)\s*â”‚\s*(\d+)\s*ms&#34;, text)
                if match:
                    address = match.group(1)
                    transaction_time = match.group(2)
                    
                    if hasattr(self, &#39;Address_label_2&#39;) and self.Address_label_2 is not None:
                        self.Address_label_2.setText(f&#34;{address}  -&#34;)
                    
                    if hasattr(self, &#39;Transaction_time_label_2&#39;) and self.Transaction_time_label_2 is not None:
                        self.Transaction_time_label_2.setText(f&#34;{transaction_time}ms&#34;)

            self.data_buffer2.append(text)
        except Exception as e:
            print(f&#34;æ•°æ®å¤„ç†é”™è¯¯ (on_data_received): {str(e)}&#34;)
        
    def create_COM_page(self):
        COM1_page = QWidget()
        layout = QVBoxLayout(COM1_page)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        top_widget = QWidget()
        top_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.2);&#34;)
        top_layout = QHBoxLayout(top_widget)
        top_layout.setContentsMargins(5, 5, 5, 5)
        
        self.port_combo = QComboBox()
        self.port_combo.setMinimumWidth(120)

        self.baud_combo = QComboBox()
        self.baud_combo.addItems([&#39;9600&#39;, &#39;115200&#39;, &#39;230400&#39;, &#39;460800&#39;, &#39;3000000&#39;])
        self.baud_combo.setCurrentText(&#39;3000000&#39;)
        self.baud_combo.setStyleSheet(self.port_combo.styleSheet())

        status_widget = QWidget()
        status_layout = QHBoxLayout(status_widget)
        status_layout.setContentsMargins(10, 0, 10, 0)
        status_layout.setSpacing(5)
        self.status_indicator = QLabel(&#34;â—&#34;)
        self.status_indicator.setStyleSheet(&#34;color: red; font-size: 16px;background:rgba(36, 42, 56, 0);&#34;)
        status_layout.addWidget(self.status_indicator)

        self.toggle_btn = QPushButton(&#34;æ‰“å¼€ä¸²å£&#34;)
        self.toggle_btn.setFixedWidth(90)
        self.toggle_btn.clicked.connect(self.toggle_port)

        line_top_1 = QFrame()
        line_top_1.setFrameShape(QFrame.Shape.VLine)
        line_top_1.setFrameShadow(QFrame.Shadow.Sunken)
        line_top_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)
        
        max_lines_label = QLabel(&#34;æœ€å¤§è¡Œæ•°&#34;) 
        max_lines_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
        
        self.max_lines_spin = QSpinBox()
        self.max_lines_spin.setRange(50000, 300000)
        self.max_lines_spin.setValue(150000)
        self.max_lines_spin.setSingleStep(10000)
        self.max_lines_spin.valueChanged.connect(self.update_max_lines)
        self.current_lines_label = QLabel(&#34;å½“å‰è¡Œæ•°: 0&#34;)
        self.current_lines_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)

        line_top_2 = QFrame()
        line_top_2.setFrameShape(QFrame.Shape.VLine)
        line_top_2.setFrameShadow(QFrame.Shadow.Sunken)
        line_top_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

        self.Address_label = QLabel(&#34;0000  -&#34;)
        self.Address_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
       
        self.Transaction_time_label = QLabel(&#34;0000ms&#34;)
        self.Transaction_time_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)

        top_layout.addWidget(self.port_combo)
        top_layout.addSpacing(10)
        top_layout.addWidget(self.baud_combo)
        top_layout.addSpacing(10)
        top_layout.addWidget(status_widget)
        top_layout.addWidget(self.toggle_btn)
        top_layout.addSpacing(20)
        top_layout.addWidget(line_top_1)
        top_layout.addSpacing(20)
        top_layout.addWidget(max_lines_label)
        top_layout.addWidget(self.max_lines_spin)
        top_layout.addSpacing(10)
        top_layout.addWidget(self.current_lines_label)
        top_layout.addSpacing(20)
        top_layout.addWidget(line_top_2)
        top_layout.addSpacing(20)
        top_layout.addWidget(self.Address_label)
        top_layout.addSpacing(5)
        top_layout.addWidget(self.Transaction_time_label)

        top_layout.addStretch()

        layout.addWidget(top_widget)

        splitter = QSplitter(Qt.Orientation.Vertical)
        splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background: transparent;
                border    : none;
                min-height: 5px;
            }
            QSplitter::handle:vertical {
                height: 5px;
            }
            QSplitter::handle:horizontal {
                width: 5px;
            }
        &#34;&#34;&#34;)
        
        self.create_display_area(splitter)
        
        bottom_widget = QWidget()
        # bottom_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.25);&#34;)
        bottom_layout = QHBoxLayout(bottom_widget)
        
        self.clear_btn = QPushButton(&#34;æ¸…å±&#34;)
        self.clear_btn.setFixedWidth(80)
        self.clear_btn.clicked.connect(self.serial_display.clear)

        self.config_highlight_btn = QPushButton(&#34;é«˜äº®&#34;)
        self.config_highlight_btn.setFixedWidth(80)
        self.config_highlight_btn.clicked.connect(self.open_highlight_config_dialog)

        self.timestamp = QCheckBox(&#34;ğŸ•’ æ—¶é—´æˆ³&#34;)
        self.timestamp.setObjectName(&#34;timestamp&#34;)
        self.timestamp.setToolTip(&#34;æ¯è¡Œå‰æ·»åŠ æ—¶é—´æˆ³&#34;)
        self.timestamp.setChecked(True)
        self.auto_scroll = QCheckBox(&#34;ğŸ“Œ è‡ªåŠ¨æ»šåŠ¨&#34;)
        self.auto_scroll.setObjectName(&#34;autoScroll&#34;)
        self.auto_scroll.setChecked(False)
        self.auto_scroll.setToolTip(&#34;é”å®šæ»šåŠ¨æ¡åˆ°åº•éƒ¨&#34;)

        line_bottom_1 = QFrame()
        line_bottom_1.setFrameShape(QFrame.Shape.VLine)
        line_bottom_1.setFrameShadow(QFrame.Shadow.Sunken)
        line_bottom_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

        line_bottom_2 = QFrame()
        line_bottom_2.setFrameShape(QFrame.Shape.VLine)
        line_bottom_2.setFrameShadow(QFrame.Shadow.Sunken)
        line_bottom_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

        # æ—¥å¿—ç›¸å…³æŒ‰é’®
        self.open_csv_log_file_btn = QPushButton(&#34;ğŸ“„CSV&#34;)
        self.open_csv_log_file_btn.setFixedWidth(75)
        self.open_csv_log_file_btn.setToolTip(&#34;æ‰“å¼€å½“å‰CSVæ—¥å¿—æ–‡ä»¶&#34;)
        self.open_csv_log_file_btn.clicked.connect(self.open_current_csv_file)
        self.open_csv_log_file_btn.setEnabled(False)

        self.open_text_log_file_btn = QPushButton(&#34;ğŸ“„TEXT&#34;)
        self.open_text_log_file_btn.setFixedWidth(75)
        self.open_text_log_file_btn.setToolTip(&#34;æ‰“å¼€å½“å‰Textæ—¥å¿—æ–‡ä»¶&#34;)
        self.open_text_log_file_btn.clicked.connect(self.open_current_text_log_file)
        self.open_text_log_file_btn.setEnabled(False)

        self.open_log_folder_btn = QPushButton(&#34;ğŸ“&#34;)
        self.open_log_folder_btn.setFixedWidth(60)
        self.open_log_folder_btn.setToolTip(&#34;æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹&#34;)
        self.open_log_folder_btn.clicked.connect(self.open_log_folder)

        bottom_layout.addWidget(self.clear_btn)
        bottom_layout.addWidget(self.config_highlight_btn)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(line_bottom_1)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(self.timestamp)
        bottom_layout.addWidget(self.auto_scroll)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(line_bottom_2)
        bottom_layout.addSpacing(10)
        bottom_layout.addWidget(self.open_csv_log_file_btn)
        bottom_layout.addWidget(self.open_text_log_file_btn)
        bottom_layout.addWidget(self.open_log_folder_btn)
        bottom_layout.addStretch()
        
        splitter.addWidget(bottom_widget)
        splitter.setSizes([2000, 100])  # è®¾ç½®åˆå§‹å¤§å°æ¯”ä¾‹
        
        layout.addWidget(splitter)
        
        # è®¾ç½®è‡ªåŠ¨æ‰«æå®šæ—¶å™¨
        self.port_scan_timer = QTimer()
        self.port_scan_timer.timeout.connect(self.refresh_ports)
        self.port_scan_timer.start(1000)
        self.refresh_ports()
        
        return COM1_page
    
    def update_max_lines(self, value):
        &#34;&#34;&#34;æ›´æ–°æ˜¾ç¤ºåŒºåŸŸæœ€å¤§è¡Œæ•°&#34;&#34;&#34;
        self.serial_display.document().setMaximumBlockCount(value)
    
    def update_current_lines(self):
        &#34;&#34;&#34;æ›´æ–°å½“å‰è¡Œæ•°æ˜¾ç¤º&#34;&#34;&#34;
        current_count = self.serial_display.document().blockCount()
        self.current_lines_label.setText(f&#34;å½“å‰è¡Œæ•°: {current_count}&#34;)
        # å¦‚æœå½“å‰è¡Œæ•°ç­‰äºæœ€å¤§è¡Œæ•°ï¼Œè‡ªåŠ¨æ¸…é™¤
        max_lines = self.serial_display.document().maximumBlockCount()
        if current_count &gt;= max_lines:
            self.serial_display.clear()

    def create_display_area(self, layout):
        &#34;&#34;&#34;åˆ›å»ºæ•°æ®æ˜¾ç¤ºåŒºåŸŸ&#34;&#34;&#34;
        self.serial_display = QTextEdit()
        self.serial_display.setReadOnly(True)
        self.serial_display.document().setMaximumBlockCount(150000)  # é™åˆ¶æœ€å¤§è¡Œæ•°
        self.serial_display.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)  # è‡ªåŠ¨æ¢è¡Œ
        self.serial_display.setWordWrapMode(QTextOption.WrapMode.WrapAnywhere)  # å…è®¸åœ¨ä»»ä½•ä½ç½®æ¢è¡Œ
        self.serial_display.installEventFilter(self) # å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨
        
        # ä¼˜åŒ–æ˜¾ç¤ºæ€§èƒ½
        self.serial_display.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.serial_display.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
        self.serial_display.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        
        # è®¾ç½®å­—ä½“å’Œæ ·å¼
        font = QFont(&#34;Microsoft YaHei&#34;, 12)
        self.serial_display.setFont(font)
        
        self.serial_display.setStyleSheet(&#34;&#34;&#34;
            QTextEdit {
                background-color          : rgba(36, 42, 56, 0.177);
                border                    : 1.5px solid #3a4a5c;
                border-radius             : 16px;
                padding                   : 12px;
                color                     : {theme[&#39;text&#39;]};
                font-size                 : 15px;
                font-family               : &#39;JetBrains Mono&#39;, &#39;Consolas&#39;, &#39;Microsoft YaHei&#39;, monospace;
                selection-background-color: #088bef;
                selection-color           : #ffffff;

            }
            QTextEdit:focus {
                border          : 1.5px solid #477faa;
                background-color: rgba(36, 42, 56, 0.5);
            }
        &#34;&#34;&#34;)
        
        # æ›´æ–°åˆå§‹è¡Œæ•°æ˜¾ç¤º
        self.serial_display.document().blockCountChanged.connect(self.update_current_lines)
        self.update_current_lines()

        # æŸ¥æ‰¾æ¡†ç›¸å…³
        self.find_dialog = QDialog(self)
        self.find_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.find_dialog.setFixedSize(300, 48)
        self.find_dialog.setStyleSheet(&#34;&#34;&#34;
            QDialog {
                background-color: rgba(45, 52, 54, 0.95);
                border          : 1px solid rgba(255, 255, 255, 0.1);
                border-radius   : 10px;
            }
        &#34;&#34;&#34;)

        find_layout = QHBoxLayout(self.find_dialog)
        find_layout.setContentsMargins(6, 6, 6, 6)
        find_layout.setSpacing(6)

        self.find_input = QLineEdit()
        self.find_input.setPlaceholderText(&#34;è¾“å…¥æœç´¢å†…å®¹&#34;)
        self.find_input.textChanged.connect(self.update_find_count)
        self.count_label = QLabel(&#34;0/0&#34;)

        # ä¸Šä¸‹ç®­å¤´æŒ‰é’®
        from PyQt6.QtWidgets import QToolButton
        self.prev_btn = QToolButton()
        self.prev_btn.setArrowType(Qt.ArrowType.UpArrow)
        self.prev_btn.clicked.connect(lambda: self.find_text(False))
        self.next_btn = QToolButton()
        self.next_btn.setArrowType(Qt.ArrowType.DownArrow)
        self.next_btn.clicked.connect(lambda: self.find_text(True))

        # å…³é—­æŒ‰é’®
        self.close_find_btn = QToolButton()
        self.close_find_btn.setText(&#34;âœ•&#34;)
        self.close_find_btn.clicked.connect(self.find_dialog.close)
        self.close_find_btn.setStyleSheet(&#34;font-size: 16px; color: #fff; background: transparent; border: none;&#34;)

        find_layout.addWidget(self.find_input)
        find_layout.addWidget(self.count_label)
        find_layout.addWidget(self.prev_btn)
        find_layout.addWidget(self.next_btn)
        find_layout.addWidget(self.close_find_btn)

        # æ·»åŠ é¼ æ ‡äº‹ä»¶å¤„ç†
        self.serial_display.wheelEvent = self.on_display_wheel
        self.serial_display.keyPressEvent = self.on_display_key_press
        self.font_size = 12  # åˆå§‹å­—ä½“å¤§å°
        
        layout.addWidget(self.serial_display)

    def create_Chart_page(self):
        Chart_page = QWidget()
        layout = QVBoxLayout(Chart_page)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        main_splitter = QSplitter(Qt.Orientation.Vertical)
        main_splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background: transparent;
                border    : none;
                min-height: 5px;
            }
            QSplitter::handle:vertical {
                height: 5px;
            }
            QSplitter::handle:horizontal {
                width: 5px;
            }
        &#34;&#34;&#34;)
        chart_widget = self.create_chart_area()
        main_splitter.addWidget(chart_widget)

        canvas_splitter = QSplitter(Qt.Orientation.Horizontal)
        canvas_splitter.setStyleSheet(&#34;&#34;&#34;
            QSplitter::handle {
                background: transparent;
                border    : none;
                min-height: 5px;
            }
            QSplitter::handle:vertical {
                height: 5px;
            }
            QSplitter::handle:horizontal {
                width: 5px;
            }
        &#34;&#34;&#34;)

        table_widget = self.create_test_area()  # è¿™é‡ŒåŒ…å«äº†è¡¨æ ¼å’Œé¢„ç•™åŒºåŸŸ
        canvas_splitter.addWidget(table_widget)
        position_widget = self.create_position_area()
        canvas_splitter.addWidget(position_widget)

        canvas_splitter.setSizes([100, 100])
        main_splitter.addWidget(canvas_splitter)
        main_splitter.setSizes([100, 200])

        layout.addWidget(main_splitter)
        return Chart_page
    
    def create_position_area(self):
        bottom_right = QWidget()
        bottom_right_layout = QVBoxLayout(bottom_right)
        bottom_right_layout.setContentsMargins(5, 5, 5, 5)
        self.position_view = PositionView()
        bottom_right_layout.addWidget(self.position_view)
        # bottom_right.setStyleSheet(&#34;background-color: rgba(255, 255, 255, 0.1); border-radius: 5px;&#34;)
        return bottom_right
    
    def create_chart_area(self):
        top_widget = QWidget()
        top_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0);&#34;)
        top_layout = QHBoxLayout(top_widget)
        top_layout.setContentsMargins(5, 5, 5, 5)
        top_layout.setSpacing(10)

        self.charts  = {}
        self.series  = {}
        chart_titles = {
            &#39;master&#39;   : &#39;Master&#39;,
            &#39;slave&#39;    : &#39;Slave&#39;,
            &#39;nlos&#39;     : &#39;NLOS&#39;,
            &#39;lift_deep&#39;: &#39;RSSI&#39;,
            &#39;speed&#39;    : &#39;Speed&#39;
        }
        for key, title in chart_titles.items():
            series = QLineSeries()
            colors = {
                &#39;master&#39;   : QColor(&#34;#FF6B6B&#34;),
                &#39;slave&#39;    : QColor(&#34;#4ECDC4&#34;),
                &#39;nlos&#39;     : QColor(&#34;#45B7D1&#34;),
                &#39;lift_deep&#39;: QColor(&#34;#68ecae&#34;),
                &#39;speed&#39;    : QColor(&#34;#FFBE0B&#34;)
            }
            series.setColor(colors[key])
            series.setPen(QPen(colors[key], 3))   # æ›²çº¿åŠ ç²—
            series.setPointsVisible(False)        # æ˜¾ç¤ºæ•°æ®ç‚¹
            series.setPointLabelsVisible(False)   # æ˜¾ç¤ºç‚¹æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰
            series.setPointLabelsColor(colors[key].darker(150))
            self.series[key] = series

            chart = QChart()
            chart.addSeries(series)
            chart.setTitle(title)
            chart.setTitleFont(QFont(&#34;Segoe UI&#34;, 12, QFont.Weight.Bold))
            chart.setTitleBrush(colors[key].darker(120))
            chart.setAnimationOptions(QChart.AnimationOption.SeriesAnimations)
            chart.legend().hide()
            
            # ä¼˜åŒ–æ¸å˜èƒŒæ™¯ - æ›´ä¸°å¯Œçš„æ¸å˜æ•ˆæœ
            gradient = QLinearGradient(0, 0, 0, 1)
            gradient.setCoordinateMode(QLinearGradient.CoordinateMode.ObjectBoundingMode)
            gradient.setColorAt(0.0, QColor(60, 62, 68, 150))   # é¡¶éƒ¨é¢œè‰²å¢å¼º
            gradient.setColorAt(0.3, QColor(50, 52, 60, 100))   # æ·»åŠ ä¸­é—´è¿‡æ¸¡è‰²
            gradient.setColorAt(0.7, QColor(40, 42, 50, 70))    # æ·»åŠ ä¸­é—´è¿‡æ¸¡è‰²
            gradient.setColorAt(1.0, QColor(32, 34, 38, 40))    # åº•éƒ¨é¢œè‰²å¾®è°ƒ
            chart.setBackgroundBrush(gradient)
            chart.setBackgroundRoundness(12)        # å¢åŠ åœ†è§’
            chart.setMargins(QMargins(8, 10, 8, 8)) # è°ƒæ•´è¾¹è·
            
            # ä¼˜åŒ–é˜´å½±æ•ˆæœ
            chart.setDropShadowEnabled(True)
            # è¾¹æ¡†ç¾åŒ–
            chart.setBackgroundPen(QPen(QColor(140, 150, 180, 70), 1.2))
            
            # Xè½´ç¾åŒ–
            axis_x = QValueAxis()
            axis_x.setRange(0, 100)
            axis_x.setLabelFormat(&#34;%d&#34;)
            axis_x.setLabelsColor(QColor(&#34;#E5E9F0&#34;).lighter(110))  # ç¨å¾®æäº®æ ‡ç­¾
            axis_x.setGridLineVisible(True)
            axis_x.setGridLineColor(QColor(255, 255, 255, 30))     # é™ä½ç½‘æ ¼çº¿ä¸é€æ˜åº¦
            axis_x.setMinorGridLineVisible(True)
            axis_x.setMinorGridLineColor(QColor(255, 255, 255, 15))
            axis_x.setLabelsFont(QFont(&#34;Segoe UI&#34;, 9))
            # axis_x.setTitleText(&#34;æ•°æ®ç‚¹&#34;)                          # æ·»åŠ è½´æ ‡é¢˜
            axis_x.setTitleFont(QFont(&#34;Segoe UI&#34;, 9, QFont.Weight.Medium))
            axis_x.setTitleBrush(QColor(&#34;#E5E9F0&#34;))
            
            # Yè½´ç¾åŒ–
            axis_y = QValueAxis()
            axis_y.setRange(-10, 10)
            axis_y.setLabelFormat(&#34;%d&#34;)
            axis_y.setLabelsColor(QColor(&#34;#E5E9F0&#34;).lighter(110))  # ç¨å¾®æäº®æ ‡ç­¾
            axis_y.setGridLineVisible(True)
            axis_y.setGridLineColor(QColor(255, 255, 255, 30))     # é™ä½ç½‘æ ¼çº¿ä¸é€æ˜åº¦
            axis_y.setMinorGridLineVisible(True)
            axis_y.setMinorGridLineColor(QColor(255, 255, 255, 15))
            axis_y.setLabelsFont(QFont(&#34;Segoe UI&#34;, 9))
            # axis_y.setTitleText(&#34;æ•°å€¼&#34;)                            # æ·»åŠ è½´æ ‡é¢˜
            axis_y.setTitleFont(QFont(&#34;Segoe UI&#34;, 9, QFont.Weight.Medium))
            axis_y.setTitleBrush(QColor(&#34;#E5E9F0&#34;))
            
            chart.addAxis(axis_x, Qt.AlignmentFlag.AlignBottom)
            chart.addAxis(axis_y, Qt.AlignmentFlag.AlignLeft)
            series.attachAxis(axis_x)
            series.attachAxis(axis_y)
            
            # ç¾åŒ–çº¿æ¡
            if isinstance(series, QLineSeries):
                pen = series.pen()
                pen.setWidth(2)                                  # å¢åŠ çº¿å®½
                series.setPen(pen)
            
            chart_view = QChartView(chart)
            chart_view.setRenderHint(QPainter.RenderHint.Antialiasing)
            chart_view.setStyleSheet(&#34;&#34;&#34;
                background   : transparent;
                border-radius: 14px;                               /* å¢åŠ è¾¹æ¡†åœ†è§’ */
                margin       : 2px;                                /* æ·»åŠ è¾¹è· */
            &#34;&#34;&#34;)

            # é¼ æ ‡æ‚¬åœæ˜¾ç¤ºæ•°æ®ç‚¹å€¼
            def show_tooltip(point, state, key=key):
                if state:
                    QToolTip.showText(QCursor.pos(), f&#34;{chart_titles[key]}: {int(point.y())}&#34;)
                else:
                    QToolTip.hideText()
            series.hovered.connect(show_tooltip)

            self.charts[key] = chart
            top_layout.addWidget(chart_view)
        return top_widget

    def create_test_area(self):
        bottom_left = QWidget()
        bottom_left.setStyleSheet(&#34;background-color: rgba(45, 52, 54,  0.15); &#34;)
        bottom_left_layout = QVBoxLayout(bottom_left)
        bottom_left_layout.setContentsMargins(0, 0, 0, 0)
        bottom_left.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        form_splitter = QSplitter(Qt.Orientation.Vertical)
        form_splitter.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        # ä¸Šéƒ¨åˆ† - æ•°æ®è¡¨æ ¼
        top_table = QWidget()
        top_table_layout = QVBoxLayout(top_table)
        top_table_layout.setContentsMargins(5, 5, 5, 5)
        top_table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

        self.data_table = QTableWidget()
        self.data_table.setColumnCount(10)
        self.data_table.setHorizontalHeaderLabels([
            &#39;Master&#39;, &#39;Slave&#39;, &#39;NLOS&#39;, &#39;RSSI&#39;, &#39;Speed&#39;,
            &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;Auth&#39;, &#39;Trans&#39;
        ])
        
        self.data_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.data_table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        top_table_layout.addWidget(self.data_table)

        # ä¸‹éƒ¨åˆ† - Test åŒºåŸŸ
        bottom_space = QWidget()
        # bottom_space.setStyleSheet(&#34;background: rgba(255, 255, 255, 0.05);&#34;)


        form_splitter.addWidget(top_table)
        form_splitter.addWidget(bottom_space)
        form_splitter.setSizes([100, 0])

        bottom_left_layout.addWidget(form_splitter)
        return bottom_left
    
    def on_display_wheel(self, event):
        &#34;&#34;&#34;å¤„ç†æ˜¾ç¤ºåŒºåŸŸçš„é¼ æ ‡æ»šè½®äº‹ä»¶&#34;&#34;&#34;
        if event.modifiers() == Qt.KeyboardModifier.ControlModifier:
            delta = event.angleDelta().y()
            if delta &gt; 0:
                self.font_size = min(self.font_size + 1, 24)  # å¢å¤§å­—ä½“ï¼Œæœ€å¤§24
            else:
                self.font_size = max(self.font_size - 1, 8)   # å‡å°å­—ä½“ï¼Œæœ€å°8
            
            # æ›´æ–°å­—ä½“å¤§å°
            self.serial_display.setStyleSheet(f&#34;&#34;&#34;
                QTextEdit {{
                    background-color: rgba(0, 0, 0, 0.2);
                    border          : 1px solid rgba(255, 255, 255, 0.1);
                    border-radius   : 10px;
                    padding         : 10px;
                    color           : #fafafa;
                    font-family     : &#39;Consolas&#39;, &#39;Courier New&#39;, monospace;
                    font-size       : {self.font_size}px;
                }}
            &#34;&#34;&#34;)
        else:
            # è°ƒç”¨åŸå§‹çš„æ»šè½®äº‹ä»¶å¤„ç†
            QTextEdit.wheelEvent(self.serial_display, event)
    
    def on_display_key_press(self, event):
        &#34;&#34;&#34;å¤„ç†æ˜¾ç¤ºåŒºåŸŸçš„é”®ç›˜äº‹ä»¶&#34;&#34;&#34;
        if event.key() == Qt.Key.Key_Space:
            self.auto_scroll.setChecked(not self.auto_scroll.isChecked())
        elif event.modifiers() == Qt.KeyboardModifier.ControlModifier and event.key() == Qt.Key.Key_F:
            # è®¡ç®—æŸ¥æ‰¾æ¡†æ˜¾ç¤ºåœ¨serial_displayå³ä¸Šè§’
            parent_pos = self.serial_display.mapToGlobal(self.serial_display.rect().topRight())
            dlg_geom = self.find_dialog.geometry()

            cursor = self.serial_display.textCursor()
            selected_text = cursor.selectedText()
            # è®©æŸ¥æ‰¾æ¡†å³ä¸Šè§’ä¸æ˜¾ç¤ºåŒºå³ä¸Šè§’å¯¹é½
            self.find_dialog.move(parent_pos.x() - dlg_geom.width(), parent_pos.y())
            self.find_dialog.show()
            self.find_input.setFocus()
            self.find_input.selectAll()
            self.auto_scroll.setChecked(True)
            if selected_text:
                self.find_input.setText(selected_text)
        # è°ƒç”¨åŸå§‹çš„é”®ç›˜äº‹ä»¶å¤„ç†
        QTextEdit.keyPressEvent(self.serial_display, event)
    
    def update_find_count(self):
        &#34;&#34;&#34;å¢é‡æ›´æ–°æŸ¥æ‰¾ç»“æœè®¡æ•°&#34;&#34;&#34;
        text = self.find_input.text()
        content = self.serial_display.toPlainText()
        # å¢é‡ç¼“å­˜ï¼šåªå¯¹æ–°å¢å†…å®¹æŸ¥æ‰¾
        if not hasattr(self, &#39;_find_count_cache&#39;):
            self._find_count_cache = {&#39;text&#39;: &#39;&#39;, &#39;content_len&#39;: 0, &#39;count&#39;: 0}
        cache = self._find_count_cache

        if not text:
            self.count_label.setText(&#34;0/0&#34;)
            cache[&#39;text&#39;]        = &#39;&#39;
            cache[&#39;content_len&#39;] = 0
            cache[&#39;count&#39;]       = 0
            return

        if text != cache[&#39;text&#39;]:
            # å…³é”®å­—å˜äº†ï¼Œé‡æ–°å…¨é‡æŸ¥æ‰¾
            count = content.count(text)
            cache[&#39;text&#39;]        = text
            cache[&#39;content_len&#39;] = len(content)
            cache[&#39;count&#39;]       = count
        else:
            # å…³é”®å­—æ²¡å˜ï¼ŒåªæŸ¥æ‰¾æ–°å¢éƒ¨åˆ†
            old_len = cache[&#39;content_len&#39;]
            if len(content) &gt; old_len:
                new_part              = content[old_len:]
                count_new             = new_part.count(text)
                cache[&#39;count&#39;]       += count_new
                cache[&#39;content_len&#39;]  = len(content)
            # å¦‚æœå†…å®¹è¢«æ¸…ç©ºæˆ–å‡å°‘ï¼Œé‡æ–°å…¨é‡æŸ¥æ‰¾
            elif len(content) &lt; old_len:
                count                = content.count(text)
                cache[&#39;count&#39;]       = count
                cache[&#39;content_len&#39;] = len(content)

        count   = cache[&#39;count&#39;]
        current = 0
        # è·å–å½“å‰é€‰ä¸­çš„ä½ç½®
        cursor = self.serial_display.textCursor()
        if cursor.hasSelection():
            sel_text = cursor.selectedText()
            if sel_text == text:
                pos     = cursor.position() - len(text)
                current = content[:pos].count(text) + 1
        self.count_label.setText(f&#34;{current}/{count}&#34;)
    
    def find_text(self, forward=True):
        text = self.find_input.text()
        if not text:
            return
        
        # ç»ˆæ­¢ä¸Šä¸€ä¸ªæŸ¥æ‰¾çº¿ç¨‹
        if hasattr(self, &#39;find_thread&#39;) and self.find_thread.isRunning():
            self.find_thread.terminate()
            self.find_thread.wait()
        
        self.auto_scroll.setChecked(True)

        content = self.serial_display.toPlainText()
        cursor  = self.serial_display.textCursor()
        cur_pos = cursor.selectionStart() if cursor.hasSelection() else cursor.position()

        # å¯åŠ¨æŸ¥æ‰¾çº¿ç¨‹
        self.find_thread = FindThread(content, text, cur_pos, forward)
        self.find_thread.result_ready.connect(self.on_find_result)
        self.find_thread.start()
    
    def on_find_result(self, current, total, positions):
        # å®šä½å¹¶é«˜äº®å½“å‰åŒ¹é…é¡¹
        pos    = positions[current]
        length = len(self.find_input.text())
        cursor = self.serial_display.textCursor()
        cursor.setPosition(pos)
        cursor.setPosition(pos + length, QTextCursor.MoveMode.KeepAnchor)
        self.serial_display.setTextCursor(cursor)

        fmt = QTextCharFormat()
        fmt.setBackground(QColor(&#34;#c3dd8c&#34;))
        fmt.setForeground(QColor(&#34;#000000&#34;))
        fmt.setFontWeight(QFont.Weight.Bold)
        cursor.mergeCharFormat(fmt)

        self._last_highlight = (pos, length)
        self.count_label.setText(f&#34;{current+1}/{total}&#34;)

    def refresh_ports(self):
        &#34;&#34;&#34;åˆ·æ–°å¯ç”¨ä¸²å£åˆ—è¡¨&#34;&#34;&#34;
        try:
            from serial.tools import list_ports
            ports = [port.device for port in list_ports.comports()]
            if set(ports) == set(self.current_ports):
                return
                
            current_port = self.port_combo.currentText()
            
            self.current_ports = ports
            self.port_combo.clear()
            for port in ports:
                self.port_combo.addItem(port)
            
            # æ¢å¤ä¹‹å‰é€‰æ‹©çš„ä¸²å£
            if current_port:
                index = self.port_combo.findText(current_port)
                if index &gt;= 0:
                    self.port_combo.setCurrentIndex(index)
                    
        except Exception as e:
            print(f&#34;è·å–ä¸²å£åˆ—è¡¨å¤±è´¥: {str(e)}&#34;)

    def toggle_port(self):
        &#34;&#34;&#34;åˆ‡æ¢ä¸²å£å¼€å…³çŠ¶æ€&#34;&#34;&#34;
        if self.toggle_btn.text() == &#34;æ‰“å¼€ä¸²å£&#34;:
            try:
                # åˆ›å»ºä¸²å£å¯¹è±¡
                self.serial_port = serial.Serial(
                    port     = self.port_combo.currentText(),
                    baudrate = int(self.baud_combo.currentText()),
                    bytesize = self.data_bits,
                    parity   = self.parity,
                    stopbits = self.stop_bits,
                    timeout  = 0.1
                )
                
                # åˆ›å»ºå¹¶å¯åŠ¨è¯»å–çº¿ç¨‹
                self.serial_thread = SerialReadThread(self.serial_port)
                self.serial_thread.data_received.connect(self.handle_serial_data)
                self.serial_thread.start()
                
                # æ›´æ–°UIçŠ¶æ€
                self.toggle_btn.setText(&#34;å…³é—­ä¸²å£&#34;)
                self.status_indicator.setStyleSheet(&#34;color: green;background:rgba(36,36,36,0);&#34;)

                current_time      = datetime.datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
                port_name         = self.port_combo.currentText().replace(&#34;:&#34;, &#34;_&#34;)
                csv_log_filename  = f&#34;[{port_name}] {current_time}.csv&#34;
                text_log_filename = f&#34;[{port_name}] {current_time}.log&#34;

                # ç¡®ä¿ logger å®ä¾‹åŠå…¶ç›®å½•å±æ€§å­˜åœ¨
                if hasattr(self.logger, &#39;csv_log_dir&#39;) and hasattr(self.logger, &#39;text_log_dir&#39;):
                    self.current_csv_log_file_path = os.path.join(self.logger.csv_log_dir, csv_log_filename)
                    self.current_text_log_file_path = os.path.join(self.logger.text_log_dir, text_log_filename)
                    self.logger.create_logger(&#34;data&#34;, csv_log_filename, &#34;csv&#34;) # åˆ›å»º CSV æ—¥å¿—
                    header_str = &#34;,&#34;.join(self.csv_title)
                    self.log_worker.add_log_task(&#34;data&#34;, &#34;info&#34;, header_str)
                    self.logger.create_logger(&#34;UwbLog&#34;, text_log_filename, &#34;text&#34;) # åˆ›å»º Text æ—¥å¿—
                    self.open_csv_log_file_btn.setEnabled(True) # å¯ç”¨æŒ‰é’®
                    self.open_text_log_file_btn.setEnabled(True)
                else:
                    # å¦‚æœæ— æ³•è·å– log_dirï¼Œåˆ™ç¦ç”¨æŒ‰é’®å¹¶æ‰“å°è­¦å‘Š
                    print(&#34;è­¦å‘Š: Logger å¯¹è±¡ç¼ºå°‘ csv_log_dir æˆ– text_log_dir å±æ€§ï¼Œ&#39;æ‰“å¼€æ—¥å¿—æ–‡ä»¶&#39;åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚&#34;)
                    self.current_csv_log_file_path  = None
                    self.current_text_log_file_path = None
                    self.open_csv_log_file_btn.setEnabled(False)
            except Exception as e:
                QMessageBox.critical(self, &#34;é”™è¯¯&#34;, f&#34;æ‰“å¼€ä¸²å£å¤±è´¥ï¼š{str(e)}&#34;)
                self.current_csv_log_file_path  = None 
                self.current_text_log_file_path = None
                self.open_csv_log_file_btn.setEnabled(False)
                return
        else:
            # å…³é—­ä¸²å£
            if hasattr(self, &#39;serial_thread&#39;):
                self.serial_thread.stop()
            if hasattr(self, &#39;serial_port&#39;):
                self.serial_port.close()
            
            # æ›´æ–°UIçŠ¶æ€
            self.toggle_btn.setText(&#34;æ‰“å¼€ä¸²å£&#34;)
            self.status_indicator.setStyleSheet(&#34;color: red;background:rgba(36,42,56,0);&#34;)
    
    def open_current_csv_file(self):
        &#34;&#34;&#34;ä½¿ç”¨ç³»ç»Ÿé»˜è®¤åº”ç”¨æ‰“å¼€å½“å‰çš„æ—¥å¿—æ–‡ä»¶&#34;&#34;&#34;
        if self.current_csv_log_file_path and os.path.exists(self.current_csv_log_file_path):
            try:
                os.startfile(self.current_csv_log_file_path) # Windows specific
            except Exception as e:
                QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€æ—¥å¿—æ–‡ä»¶ï¼š\n{e}&#34;)
        else:
            QMessageBox.information(self, &#34;æç¤º&#34;, &#34;å½“å‰æ²¡æœ‰æ´»åŠ¨çš„æ—¥å¿—æ–‡ä»¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚&#34;)
    
    def open_current_text_log_file(self):
        &#34;&#34;&#34;ä½¿ç”¨ç³»ç»Ÿé»˜è®¤åº”ç”¨æ‰“å¼€å½“å‰çš„ Text æ—¥å¿—æ–‡ä»¶&#34;&#34;&#34;
        if self.current_text_log_file_path and os.path.exists(self.current_text_log_file_path):
            try:
                os.startfile(self.current_text_log_file_path) # Windows specific
            except Exception as e:
                QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€ Text æ—¥å¿—æ–‡ä»¶ï¼š\n{e}&#34;)
        else:
            QMessageBox.information(self, &#34;æç¤º&#34;, &#34;å½“å‰æ²¡æœ‰æ´»åŠ¨çš„ Text æ—¥å¿—æ–‡ä»¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚&#34;)
    
    def open_current_text_log_file2(self):
        if self.current_text_log_file_path2 and os.path.exists(self.current_text_log_file_path2):
            try:
                os.startfile(self.current_text_log_file_path2) # Windows specific
            except Exception as e:
                QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€ Text æ—¥å¿—æ–‡ä»¶ï¼š\n{e}&#34;)
        else:
            QMessageBox.information(self, &#34;æç¤º&#34;, &#34;å½“å‰æ²¡æœ‰æ´»åŠ¨çš„ Text æ—¥å¿—æ–‡ä»¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚&#34;)

    def open_log_folder(self):
        &#34;&#34;&#34;ä½¿ç”¨ç³»ç»Ÿæ–‡ä»¶æµè§ˆå™¨æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹&#34;&#34;&#34;
        log_dir = getattr(self.logger, &#39;log_dir&#39;, None)
        if log_dir and os.path.isdir(log_dir):
            try:
                os.startfile(log_dir) # Windows specific
                return 
            except Exception as e:
                QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€æ—¥å¿—ç›®å½• &#39;{log_dir}&#39;ï¼š\n{e}&#34;)

        # å¦‚æœ logger æ²¡æœ‰ log_dir æˆ–ç›®å½•ä¸å­˜åœ¨ï¼Œå¯ä»¥å°è¯•æ‰“å¼€ç¨‹åºè¿è¡Œç›®å½•ä¸‹çš„ &#39;UWBLogs&#39; æ–‡ä»¶å¤¹
        fallback_dir = os.path.join(os.path.dirname(__file__), &#39;UWBLogs&#39;) 
        if os.path.isdir(fallback_dir):
             try:
                os.startfile(fallback_dir)
             except Exception as e:
                QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€å¤‡é€‰æ—¥å¿—ç›®å½• &#39;{fallback_dir}&#39;ï¼š\n{e}&#34;)
        else:
            QMessageBox.warning(self, &#34;é”™è¯¯&#34;, &#34;æ— æ³•ç¡®å®šæ—¥å¿—ç›®å½•ï¼Œä¸»ç›®å½•å’Œå¤‡é€‰ç›®å½•å‡æœªæ‰¾åˆ°ã€‚&#34;)
    
    def update_chart(self, chart_key, value):
        &#34;&#34;&#34;æ›´æ–°å›¾è¡¨ï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œï¼‰&#34;&#34;&#34;
        try:
            series = self.series[chart_key]
            data_list = self.uwb_data[chart_key]
            
            # å¦‚æœç‚¹æ•°è¶…è¿‡100ï¼Œç§»é™¤æœ€æ—§çš„ç‚¹
            if series.count() &gt;= 100:
                series.remove(0)
            
            # æ›´æ–°æ‰€æœ‰ç‚¹çš„Xåæ ‡
            for i in range(series.count()):
                old_point = series.at(i)
                series.replace(i, QPointF(i, old_point.y()))
            
            # æ·»åŠ æ–°ç‚¹
            series.append(len(data_list) - 1, value)
            
            # æ›´æ–°Yè½´èŒƒå›´
            if data_list:
                min_val = min(data_list)
                max_val = max(data_list)
                margin  = (max_val - min_val) * 0.1 if max_val != min_val else 1.0
                chart   = self.charts[chart_key]
                y_axis  = chart.axes(Qt.Orientation.Vertical)[0]
                y_axis.setRange(min_val - margin, max_val + margin)
            
            data = self.uwb_data.get(chart_key, [])
            chart = self.charts[chart_key]

            if data:
                mean = sum(data) / len(data)
                std = (sum((x - mean) ** 2 for x in data) / len(data)) ** 0.5
                display_key = &#34;RSSI&#34; if chart_key == &#34;lift_deep&#34; else chart_key.upper()
                title = f&#34;{display_key} | Avg: {mean:.1f} | Std: {std:.1f}&#34;
            else:
                mean = 0
                std = 0
                title = chart_key.upper()
            chart.setTitle(title)

            n = len(data)
            # ===== å‡å€¼çº¿ =====
            if not hasattr(self, &#34;mean_series&#34;):
                self.mean_series = {}
            if chart_key not in self.mean_series:
                from PyQt6.QtCharts import QLineSeries
                mean_series = QLineSeries()
                mean_series.setColor(QColor(255, 255, 255))  # ç´«è‰²
                mean_series.setPen(QPen(QColor(255, 255, 255), 3, Qt.PenStyle.DashLine))  # å®çº¿åŠ ç²—
                chart.addSeries(mean_series)
                mean_series.attachAxis(chart.axes(Qt.Orientation.Horizontal)[0])
                mean_series.attachAxis(chart.axes(Qt.Orientation.Vertical)[0])
                self.mean_series[chart_key] = mean_series
            else:
                mean_series = self.mean_series[chart_key]
            mean_series.clear()
            if n &gt; 1:
                mean_series.append(0, mean)
                mean_series.append(n-1, mean)
            # ===== æ ‡å‡†å·®å¸¦ =====
            if not hasattr(self, &#34;std_area&#34;):
                self.std_area = {}
            if chart_key not in self.std_area:
                from PyQt6.QtCharts import QLineSeries, QAreaSeries
                upper = QLineSeries()
                lower = QLineSeries()
                area = QAreaSeries(upper, lower)
                area.setColor(QColor(0, 120, 255, 60))  # è“è‰²åŠé€æ˜
                area.setPen(QPen(QColor(0, 120, 255, 120), 1))
                chart.addSeries(area)
                area.attachAxis(chart.axes(Qt.Orientation.Horizontal)[0])
                area.attachAxis(chart.axes(Qt.Orientation.Vertical)[0])
                self.std_area[chart_key] = (upper, lower, area)
            else:
                upper, lower, area = self.std_area[chart_key]
            upper.clear()
            lower.clear()
            for i in range(n):
                upper.append(i, mean + std)
                lower.append(i, mean - std)

        except Exception as e:
            print(f&#34;Error updating chart: {str(e)}&#34;)

    def handle_serial_data(self, data):
        try:
            text = data.decode(&#39;utf-8&#39;)
            
            self.log_worker.add_log_task(&#34;UwbLog&#34;, &#34;info&#34;, text.strip())
            text = re.sub(r&#39;\x1b\[[0-9;]*[a-zA-Z]&#39;, &#39;&#39;, text)
            self.data_buffer.append(text)

            if &#34;@@@ Time of Write Card End&#34; in text:
                #&#34;@@@ Time of Write Card End     = 00:14:520  â”‚ 80D7 â”‚  710 ms&#34;
                match = re.search(r&#34;â”‚\s*([0-9A-Fa-f]+)\s*â”‚\s*(\d+)\s*ms&#34;, text)
                if match:
                    address = match.group(1)
                    transaction_time = match.group(2)
                    
                    if hasattr(self, &#39;Address_label&#39;) and self.Address_label is not None:
                        self.Address_label.setText(f&#34;{address}  -&#34;)
                    
                    if hasattr(self, &#39;Transaction_time_label&#39;) and self.Transaction_time_label is not None:
                        self.Transaction_time_label.setText(f&#34;{transaction_time}ms&#34;)
            
            if &#34;@POSITION&#34; in text:
                # print(f&#39;æ¥æ”¶åˆ°åŸå§‹æ•°æ®ï¼š{repr(text)}&#39;)
                try:
                    json_data = json.loads(text)
                except json.JSONDecodeError as e:
                    print(f&#34;JSONè§£æé”™è¯¯: {e}&#34;)
                    return
                # æå–ç”¨æˆ·åæ ‡
                user_x = float(json_data.get(&#39;User-X&#39;, 0))
                user_y = float(json_data.get(&#39;User-Y&#39;, 0))
                user_z = float(json_data.get(&#39;User-Z&#39;, 0))
                
                # Map JSON keys to chart keys
                key_mapping = {
                    &#39;master&#39;   : &#39;Master&#39;,
                    &#39;slave&#39;    : &#39;Slave&#39;,
                    &#39;nlos&#39;     : &#39;nLos&#39;,
                    &#39;lift_deep&#39;: &#39;LiftDeep&#39;,
                    &#39;speed&#39;    : &#39;Speed&#39;
                }
                
                # Update data with correct key mapping
                for chart_key, json_key in key_mapping.items():
                    try:
                        value = int(json_data.get(json_key, 0))
                        self.uwb_data[chart_key].append(value)

                        if len(self.uwb_data[chart_key]) &gt; 100:
                            self.uwb_data[chart_key] = self.uwb_data[chart_key][-100:]
                        
                        self.chart_thread.add_data(chart_key, value)
                            
                    except (ValueError, TypeError):
                        continue

                # Log data
                data_values = [
                    json_data.get(&#39;Master&#39;, 0),
                    json_data.get(&#39;Slave&#39;, 0),
                    json_data.get(&#39;nLos&#39;, 0),
                    json_data.get(&#39;LiftDeep&#39;, 0),
                    json_data.get(&#39;Speed&#39;, 0),
                    json_data.get(&#39;User-X&#39;, 0),
                    json_data.get(&#39;User-Y&#39;, 0),
                    json_data.get(&#39;User-Z&#39;, 0),
                    json_data.get(&#39;Auth&#39;, 0),
                    json_data.get(&#39;Trans&#39;, 0)
                ]
                
                # å†™å…¥CSV
                csv_data = &#34;,&#34;.join(str(val) for val in data_values)
                self.log_worker.add_log_task(&#34;data&#34;, &#34;info&#34;, csv_data)
                
                # ç¼“å­˜è¡¨æ ¼æ•°æ®ï¼Œå»¶åæ‰¹é‡æ’å…¥
                if not hasattr(self, &#39;pending_table_rows&#39;):
                    self.pending_table_rows = []
                self.pending_table_rows.append(data_values)

                # æ›´æ–°ç”¨æˆ·ä½ç½®æ˜¾ç¤ºï¼ˆä»…å½“æœ‰æ˜æ˜¾åç§»æ—¶ï¼‰
                if hasattr(self, &#39;position_view&#39;):
                    last_pos = getattr(self.position_view, &#34;current_position&#34;, None)
                    threshold = 2  # ä¾‹å¦‚5ç±³æˆ–5åƒç´ ï¼Œæ ¹æ®ä½ çš„scaleè°ƒæ•´
                    if last_pos is None or ((user_x - last_pos[0]) ** 2 + (user_y - last_pos[1]) ** 2) ** 0.5 &gt; threshold:
                        self.position_view.update_position(user_x, user_y)
                        
        except Exception as e:
            print(f&#34;Error processing serial data: {str(e)}&#34;)

    def update_display(self):
        &#34;&#34;&#34;æ›´æ–°æ˜¾ç¤ºåŒºåŸŸ&#34;&#34;&#34;
        if self.data_buffer:
            cursor         = self.serial_display.textCursor()
            scrollbar      = self.serial_display.verticalScrollBar()
            current_scroll = scrollbar.value()
            
            text = &#39;&#39;.join(self.data_buffer)
            
            # å¦‚æœé€‰ä¸­äº†æ—¶é—´æˆ³é€‰é¡¹ï¼Œä¸ºæ¯è¡Œæ·»åŠ æ—¶é—´æˆ³
            if self.timestamp.isChecked():
                lines = text.splitlines(True) 
                timestamp = QDateTime.currentDateTime().toString(&#39;[yyyy-MM-dd hh:mm:ss.zzz] &#39;)
                text = &#39;&#39;.join(timestamp + line for line in lines)
            
            self.serial_display.setUpdatesEnabled(False)
            cursor.movePosition(QTextCursor.MoveOperation.End)
            insert_pos = cursor.position()
            cursor.insertText(text)
            self.data_buffer.clear()
            self.serial_display.setUpdatesEnabled(True)

            if self.highlight_config: 
                doc       = self.serial_display.document()
                start_pos = insert_pos
                end_pos   = insert_pos + len(text)
                block     = doc.findBlock(start_pos)

                if not block.isValid(): 
                    block = doc.begin()

                while block.isValid() and block.position() &lt; end_pos:
                    block_text  = block.text()
                    block_start = block.position()

                    for keyword, color in self.highlight_config.items():
                        if not keyword: continue 

                        highlight_fmt = QTextCharFormat()
                        highlight_fmt.setBackground(color) 
                        luminance = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255
                        text_color = QColor(&#34;#000000&#34;) if luminance &gt; 0.5 else QColor(&#34;#FFFFFF&#34;)
                        highlight_fmt.setForeground(text_color)
                        highlight_fmt.setFontWeight(QFont.Weight.Bold)

                        idx = block_text.find(keyword)
                        while idx != -1:
                            abs_pos = block_start + idx
                            if abs_pos &gt;= start_pos and abs_pos + len(keyword) &lt;= end_pos:
                                highlight_cursor = QTextCursor(doc)
                                highlight_cursor.setPosition(abs_pos)
                                highlight_cursor.setPosition(abs_pos + len(keyword), QTextCursor.MoveMode.KeepAnchor)
                                highlight_cursor.mergeCharFormat(highlight_fmt)
                            idx = block_text.find(keyword, idx + len(keyword))
                    block = block.next()

            # æ›´æ–°æŸ¥æ‰¾è®¡æ•°
            if self.find_dialog.isVisible():
                self.update_find_count()
            
            if self.auto_scroll.isChecked():
                scrollbar.setValue(current_scroll)
            else:
                scrollbar.setValue(scrollbar.maximum())

        if hasattr(self, &#39;pending_table_rows&#39;) and len(self.pending_table_rows) &gt;= 5:
            for data_values in self.pending_table_rows:
                row_position = self.data_table.rowCount()
                self.data_table.insertRow(row_position)
                for col, value in enumerate(data_values):
                    self.data_table.setItem(row_position, col, QTableWidgetItem(str(value)))
                if self.data_table.rowCount() &gt; 100:
                    self.data_table.removeRow(0)
            self.data_table.scrollToBottom()
            self.pending_table_rows.clear()
    
    def update_display2(self):
        &#34;&#34;&#34;æ›´æ–°æ˜¾ç¤ºåŒºåŸŸ2&#34;&#34;&#34;
        if self.data_buffer2:
            cursor         = self.serial_display2.textCursor()
            scrollbar      = self.serial_display2.verticalScrollBar()
            current_scroll = scrollbar.value()
            text           = &#39;&#39;.join(self.data_buffer2)
            
            # å¦‚æœé€‰ä¸­äº†æ—¶é—´æˆ³é€‰é¡¹ï¼Œä¸ºæ¯è¡Œæ·»åŠ æ—¶é—´æˆ³
            if self.timestamp2.isChecked():
                lines     = text.splitlines(True)
                timestamp = QDateTime.currentDateTime().toString(&#39;[yyyy-MM-dd hh:mm:ss.zzz] &#39;)
                text      = &#39;&#39;.join(timestamp + line for line in lines)
            
            self.serial_display2.setUpdatesEnabled(False)
            cursor.movePosition(QTextCursor.MoveOperation.End)
            insert_pos = cursor.position()
            cursor.insertText(text)
            self.data_buffer2.clear()
            self.serial_display2.setUpdatesEnabled(True)

            # å¤„ç†é«˜äº®
            if self.highlight_config:
                doc       = self.serial_display2.document()
                start_pos = insert_pos
                end_pos   = insert_pos + len(text)
                block     = doc.findBlock(start_pos)

                if not block.isValid():
                    block = doc.begin()

                while block.isValid() and block.position() &lt; end_pos:
                    block_text  = block.text()
                    block_start = block.position()
                    for keyword, color in self.highlight_config.items():
                        if not keyword:
                            continue
                        highlight_fmt = QTextCharFormat()
                        highlight_fmt.setBackground(color)
                        luminance = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255
                        text_color = QColor(&#34;#000000&#34;) if luminance &gt; 0.5 else QColor(&#34;#FFFFFF&#34;)
                        highlight_fmt.setForeground(text_color)
                        highlight_fmt.setFontWeight(QFont.Weight.Bold)
                        
                        idx = block_text.find(keyword)
                        while idx != -1:
                            abs_pos = block_start + idx
                            if abs_pos &gt;= start_pos and abs_pos + len(keyword) &lt;= end_pos:
                                highlight_cursor = QTextCursor(doc)
                                highlight_cursor.setPosition(abs_pos)
                                highlight_cursor.setPosition(abs_pos + len(keyword), QTextCursor.MoveMode.KeepAnchor)
                                highlight_cursor.setCharFormat(highlight_fmt)
                            idx = block_text.find(keyword, idx + len(keyword))
                    block = block.next()

            # æ›´æ–°æŸ¥æ‰¾è®¡æ•°
            if self.find_dialog2.isVisible():
                self.update_find_count2()
            
            if self.auto_scroll2.isChecked():
                scrollbar.setValue(current_scroll)
            else:
                scrollbar.setValue(scrollbar.maximum())

    def toggle_theme(self):
        self.background_image_index = (self.background_image_index + 1) % len(self.background_images)
        self.background_image = self.background_images[self.background_image_index]
        # åˆ‡æ¢èƒŒæ™¯å›¾ç‰‡å¹¶åˆ·æ–°
        background_path = Path(__file__).parent / self.background_image
        if background_path.exists():
            background = QPixmap(str(background_path))
            self.background_cache = background.scaled(
                self.size(),
                Qt.AspectRatioMode.KeepAspectRatioByExpanding,
                Qt.TransformationMode.SmoothTransformation
            )
            self.last_window_size = self.size()
        self._save_background_config()
        self.update()
    
    def apply_theme(self):
        theme = self.current_theme
        self.setStyleSheet(f&#34;&#34;&#34;
            QMainWindow {{
                background-color: {theme[&#39;bg&#39;]};
            }}
            QWidget#titleBar {{
                background-color: {theme[&#39;title_bg&#39;]} !important;
            }}
            QLabel#titleLabel {{
                color           : #C29500;              /* å›ºå®šå­—ä½“é¢œè‰² */
                font-weight     : bold;
                background-color: {theme[&#39;title_bg&#39;]};  /* ç»§æ‰¿æ ‡é¢˜æ èƒŒæ™¯è‰² */
            }}
            QWidget {{
                background-color: {theme[&#39;bg&#39;]};
                color           : {theme[&#39;text&#39;]};
            }}
            QListWidget {{
                background-color: {theme[&#39;nav_bg&#39;]};
                border          : none;
            }}
            QListWidget::item {{
                color      : {theme[&#39;nav_item&#39;]};
                border-left: 4px solid transparent;
            }}
            QListWidget::item:selected {{
                background-color: {theme[&#39;nav_selected&#39;]};
                border-left     : 4px solid {theme[&#39;accent&#39;]};
            }}
            QComboBox:hover {{
                background: rgba(90, 110, 140, 0.604);
                border: 1px solid {theme[&#39;accent&#39;]};
            }}
            QPushButton {{
                background   : rgba(90, 110, 140, 0.33);
                color        : {theme[&#39;text&#39;]};
                border       : 1px solid rgba(90, 110, 140, 0.18);
                padding      : 4px 12px;
                border-radius: 8px;
                font-size    : 13px;
            }}
            QPushButton:hover {{

                border: 1px solid {theme[&#39;accent&#39;]};
            }}
            QLineEdit {{
                background   : rgba(255, 255, 255, 0.35);
                border       : 1px solid rgba(0, 0, 0, 0.35);
                border-radius: 15px;
                font-size    : 14px;
                padding      : 8px;
            }}
            QScrollBar:vertical {{
                background   : rgba(36, 42, 56, 0.08);
                width        : 12px;
                margin       : 4px 0 4px 0;
                border-radius: 6px;
            }}
            QScrollBar::handle:vertical {{
                background: qlineargradient(
                    x1:0, y1:0, x2:1, y2:1,
                    stop:0 #4a90e2, stop:1 #1e293b
                );
                min-height   : 28px;
                border-radius: 6px;
                border       : 1px solid #3da9fc;
            }}
            QScrollBar::handle:vertical:hover {{
                background: qlineargradient(
                    x1:0, y1:0, x2:1, y2:1,
                    stop:0 #90caf9, stop:1 #3da9fc
                );
                border: 1.5px solid #66abf5;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                height    : 0;
                background: none;
                border    : none;
            }}
            QScrollBar:horizontal {{
                background   : rgba(36, 42, 56, 0.08);
                height       : 12px;
                margin       : 0 4px 0 4px;
                border-radius: 6px;
            }}
            QScrollBar::handle:horizontal {{
                background: qlineargradient(
                    x1:0, y1:0, x2:1, y2:1,
                    stop:0 #4a90e2, stop:1 #1e293b
                );
                min-width    : 28px;
                border-radius: 6px;
                border       : 1px solid #3da9fc;
            }}
            QScrollBar::handle:horizontal:hover {{
                background: qlineargradient(
                    x1:0, y1:0, x2:1, y2:1,
                    stop:0 #90caf9, stop:1 #3da9fc
                );
                border: 1.5px solid #66abf5;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                width     : 0;
                background: none;
                border    : none;
            }}
            QCheckBox {{
                color    : {theme[&#39;text&#39;]};
                spacing  : 5px;
                padding  : 2px;
                font-size: 12px;
            }}
            QCheckBox::indicator {{
                width        : 16px;
                height       : 16px;
                border       : 1px solid #a0a4ad;
                border-radius: 4px;
                background   : transparent;
            }}
            QCheckBox::indicator:hover {{
                border    : 1px solid {theme[&#39;accent&#39;]};
                background: rgba(90, 110, 140, 0.10);
            }}
            QCheckBox::indicator:checked {{
                background-color: {theme[&#39;accent&#39;]};
                border          : 1px solid {theme[&#39;accent&#39;]};
            }}
            QCheckBox::indicator:checked:hover {{
                background-color: {theme[&#39;accent&#39;]};
                border          : 1px solid {theme[&#39;accent&#39;]};
            }}
            QCheckBox::indicator:checked:disabled {{
                background-color: #cccccc;
                border          : 1px solid #cccccc;
            }}
        &#34;&#34;&#34;)
        if hasattr(self, &#34;data_table&#34;):
            self.data_table.setAlternatingRowColors(True)
            self.data_table.setStyleSheet(f&#34;&#34;&#34;
                QTableWidget {{
                    background                : transparent;
                    border                    : 1.5px solid #3a4a5c;
                    border-radius             : 14px;
                    selection-background-color: {theme[&#39;accent&#39;]};
                    selection-color           : #fff;
                    alternate-background-color: rgba(255,255,255,0.08);
                    font-size                 : 13px;
                    font-family               : &#39;JetBrains Mono&#39;, &#39;Consolas&#39;, &#39;Microsoft YaHei&#39;, monospace;
                    color                     : {theme[&#39;text&#39;]};
                }}
                QHeaderView::section {{
                    background             : {theme[&#39;nav_bg&#39;]};
                    color                  : {theme[&#39;nav_item&#39;]};
                    border                 : none;
                    padding                : 8px 5px;
                    font-weight            : bold;
                    font-size              : 13px;
                    border-top-left-radius : 10px;
                    border-top-right-radius: 10px;
                }}
                QTableWidget::item {{
                    color     : {theme[&#39;text&#39;]};
                    border    : none;
                    background: transparent;
                    font-size : 13px;
                }}
                QTableWidget::item:selected {{
                    background: {theme[&#39;accent&#39;]};
                    color     : #fff;
                }}
                QTableWidget::item:hover {{
                    background: rgba(76, 175, 255, 0.18);
                }}
                QTableWidget::viewport {{
                    background: transparent;
                }}
                QTableCornerButton::section {{
                    background            : {theme[&#39;nav_bg&#39;]};
                    border                : none;
                    border-top-left-radius: 10px;
                }}
            &#34;&#34;&#34;)
            self.data_table.setShowGrid(False)
        
    def switch_page(self, index):
        self.stacked_widget.setCurrentIndex(index)
        if index != 0:  
            self.find_dialog.close()
        if index != 1:
            self.find_dialog2.close()</code></pre>
</details>
<div class="desc"><p>UWBDash ä¸»çª—å£ç±»</p>
<p>è¿™æ˜¯ä¸€ä¸ªåŸºäº PyQt6 çš„ UWB æ•°æ®å¯è§†åŒ–å·¥å…·ã€‚ä¸»è¦åŠŸèƒ½åŒ…æ‹¬:
- åŒä¸²å£æ•°æ®æ¥æ”¶å’Œæ˜¾ç¤º
- UWB æ•°æ®å®æ—¶å›¾è¡¨å±•ç¤º
- è‡ªå®šä¹‰ä¸»é¢˜åˆ‡æ¢
- æ—¥å¿—è®°å½•åŠŸèƒ½</p>
<p>åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢</p>
<p>åˆ›å»ºå¹¶è®¾ç½®:
- æ ‡é¢˜æ 
- å¯¼èˆªæ 
- ä¸»å†…å®¹åŒºåŸŸ
- ä¸»é¢˜æ ·å¼</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtWidgets.QMainWindow</li>
<li>PyQt6.QtWidgets.QWidget</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.QtGui.QPaintDevice</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.MainWindow.apply_theme"><code class="name flex">
<span>def <span class="ident">apply_theme</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_theme(self):
    theme = self.current_theme
    self.setStyleSheet(f&#34;&#34;&#34;
        QMainWindow {{
            background-color: {theme[&#39;bg&#39;]};
        }}
        QWidget#titleBar {{
            background-color: {theme[&#39;title_bg&#39;]} !important;
        }}
        QLabel#titleLabel {{
            color           : #C29500;              /* å›ºå®šå­—ä½“é¢œè‰² */
            font-weight     : bold;
            background-color: {theme[&#39;title_bg&#39;]};  /* ç»§æ‰¿æ ‡é¢˜æ èƒŒæ™¯è‰² */
        }}
        QWidget {{
            background-color: {theme[&#39;bg&#39;]};
            color           : {theme[&#39;text&#39;]};
        }}
        QListWidget {{
            background-color: {theme[&#39;nav_bg&#39;]};
            border          : none;
        }}
        QListWidget::item {{
            color      : {theme[&#39;nav_item&#39;]};
            border-left: 4px solid transparent;
        }}
        QListWidget::item:selected {{
            background-color: {theme[&#39;nav_selected&#39;]};
            border-left     : 4px solid {theme[&#39;accent&#39;]};
        }}
        QComboBox:hover {{
            background: rgba(90, 110, 140, 0.604);
            border: 1px solid {theme[&#39;accent&#39;]};
        }}
        QPushButton {{
            background   : rgba(90, 110, 140, 0.33);
            color        : {theme[&#39;text&#39;]};
            border       : 1px solid rgba(90, 110, 140, 0.18);
            padding      : 4px 12px;
            border-radius: 8px;
            font-size    : 13px;
        }}
        QPushButton:hover {{

            border: 1px solid {theme[&#39;accent&#39;]};
        }}
        QLineEdit {{
            background   : rgba(255, 255, 255, 0.35);
            border       : 1px solid rgba(0, 0, 0, 0.35);
            border-radius: 15px;
            font-size    : 14px;
            padding      : 8px;
        }}
        QScrollBar:vertical {{
            background   : rgba(36, 42, 56, 0.08);
            width        : 12px;
            margin       : 4px 0 4px 0;
            border-radius: 6px;
        }}
        QScrollBar::handle:vertical {{
            background: qlineargradient(
                x1:0, y1:0, x2:1, y2:1,
                stop:0 #4a90e2, stop:1 #1e293b
            );
            min-height   : 28px;
            border-radius: 6px;
            border       : 1px solid #3da9fc;
        }}
        QScrollBar::handle:vertical:hover {{
            background: qlineargradient(
                x1:0, y1:0, x2:1, y2:1,
                stop:0 #90caf9, stop:1 #3da9fc
            );
            border: 1.5px solid #66abf5;
        }}
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
            height    : 0;
            background: none;
            border    : none;
        }}
        QScrollBar:horizontal {{
            background   : rgba(36, 42, 56, 0.08);
            height       : 12px;
            margin       : 0 4px 0 4px;
            border-radius: 6px;
        }}
        QScrollBar::handle:horizontal {{
            background: qlineargradient(
                x1:0, y1:0, x2:1, y2:1,
                stop:0 #4a90e2, stop:1 #1e293b
            );
            min-width    : 28px;
            border-radius: 6px;
            border       : 1px solid #3da9fc;
        }}
        QScrollBar::handle:horizontal:hover {{
            background: qlineargradient(
                x1:0, y1:0, x2:1, y2:1,
                stop:0 #90caf9, stop:1 #3da9fc
            );
            border: 1.5px solid #66abf5;
        }}
        QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
            width     : 0;
            background: none;
            border    : none;
        }}
        QCheckBox {{
            color    : {theme[&#39;text&#39;]};
            spacing  : 5px;
            padding  : 2px;
            font-size: 12px;
        }}
        QCheckBox::indicator {{
            width        : 16px;
            height       : 16px;
            border       : 1px solid #a0a4ad;
            border-radius: 4px;
            background   : transparent;
        }}
        QCheckBox::indicator:hover {{
            border    : 1px solid {theme[&#39;accent&#39;]};
            background: rgba(90, 110, 140, 0.10);
        }}
        QCheckBox::indicator:checked {{
            background-color: {theme[&#39;accent&#39;]};
            border          : 1px solid {theme[&#39;accent&#39;]};
        }}
        QCheckBox::indicator:checked:hover {{
            background-color: {theme[&#39;accent&#39;]};
            border          : 1px solid {theme[&#39;accent&#39;]};
        }}
        QCheckBox::indicator:checked:disabled {{
            background-color: #cccccc;
            border          : 1px solid #cccccc;
        }}
    &#34;&#34;&#34;)
    if hasattr(self, &#34;data_table&#34;):
        self.data_table.setAlternatingRowColors(True)
        self.data_table.setStyleSheet(f&#34;&#34;&#34;
            QTableWidget {{
                background                : transparent;
                border                    : 1.5px solid #3a4a5c;
                border-radius             : 14px;
                selection-background-color: {theme[&#39;accent&#39;]};
                selection-color           : #fff;
                alternate-background-color: rgba(255,255,255,0.08);
                font-size                 : 13px;
                font-family               : &#39;JetBrains Mono&#39;, &#39;Consolas&#39;, &#39;Microsoft YaHei&#39;, monospace;
                color                     : {theme[&#39;text&#39;]};
            }}
            QHeaderView::section {{
                background             : {theme[&#39;nav_bg&#39;]};
                color                  : {theme[&#39;nav_item&#39;]};
                border                 : none;
                padding                : 8px 5px;
                font-weight            : bold;
                font-size              : 13px;
                border-top-left-radius : 10px;
                border-top-right-radius: 10px;
            }}
            QTableWidget::item {{
                color     : {theme[&#39;text&#39;]};
                border    : none;
                background: transparent;
                font-size : 13px;
            }}
            QTableWidget::item:selected {{
                background: {theme[&#39;accent&#39;]};
                color     : #fff;
            }}
            QTableWidget::item:hover {{
                background: rgba(76, 175, 255, 0.18);
            }}
            QTableWidget::viewport {{
                background: transparent;
            }}
            QTableCornerButton::section {{
                background            : {theme[&#39;nav_bg&#39;]};
                border                : none;
                border-top-left-radius: 10px;
            }}
        &#34;&#34;&#34;)
        self.data_table.setShowGrid(False)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_COM_page"><code class="name flex">
<span>def <span class="ident">create_COM_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_COM_page(self):
    COM1_page = QWidget()
    layout = QVBoxLayout(COM1_page)
    layout.setContentsMargins(10, 10, 10, 10)
    layout.setSpacing(10)
    
    top_widget = QWidget()
    top_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.2);&#34;)
    top_layout = QHBoxLayout(top_widget)
    top_layout.setContentsMargins(5, 5, 5, 5)
    
    self.port_combo = QComboBox()
    self.port_combo.setMinimumWidth(120)

    self.baud_combo = QComboBox()
    self.baud_combo.addItems([&#39;9600&#39;, &#39;115200&#39;, &#39;230400&#39;, &#39;460800&#39;, &#39;3000000&#39;])
    self.baud_combo.setCurrentText(&#39;3000000&#39;)
    self.baud_combo.setStyleSheet(self.port_combo.styleSheet())

    status_widget = QWidget()
    status_layout = QHBoxLayout(status_widget)
    status_layout.setContentsMargins(10, 0, 10, 0)
    status_layout.setSpacing(5)
    self.status_indicator = QLabel(&#34;â—&#34;)
    self.status_indicator.setStyleSheet(&#34;color: red; font-size: 16px;background:rgba(36, 42, 56, 0);&#34;)
    status_layout.addWidget(self.status_indicator)

    self.toggle_btn = QPushButton(&#34;æ‰“å¼€ä¸²å£&#34;)
    self.toggle_btn.setFixedWidth(90)
    self.toggle_btn.clicked.connect(self.toggle_port)

    line_top_1 = QFrame()
    line_top_1.setFrameShape(QFrame.Shape.VLine)
    line_top_1.setFrameShadow(QFrame.Shadow.Sunken)
    line_top_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)
    
    max_lines_label = QLabel(&#34;æœ€å¤§è¡Œæ•°&#34;) 
    max_lines_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
    
    self.max_lines_spin = QSpinBox()
    self.max_lines_spin.setRange(50000, 300000)
    self.max_lines_spin.setValue(150000)
    self.max_lines_spin.setSingleStep(10000)
    self.max_lines_spin.valueChanged.connect(self.update_max_lines)
    self.current_lines_label = QLabel(&#34;å½“å‰è¡Œæ•°: 0&#34;)
    self.current_lines_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)

    line_top_2 = QFrame()
    line_top_2.setFrameShape(QFrame.Shape.VLine)
    line_top_2.setFrameShadow(QFrame.Shadow.Sunken)
    line_top_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

    self.Address_label = QLabel(&#34;0000  -&#34;)
    self.Address_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
   
    self.Transaction_time_label = QLabel(&#34;0000ms&#34;)
    self.Transaction_time_label.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)

    top_layout.addWidget(self.port_combo)
    top_layout.addSpacing(10)
    top_layout.addWidget(self.baud_combo)
    top_layout.addSpacing(10)
    top_layout.addWidget(status_widget)
    top_layout.addWidget(self.toggle_btn)
    top_layout.addSpacing(20)
    top_layout.addWidget(line_top_1)
    top_layout.addSpacing(20)
    top_layout.addWidget(max_lines_label)
    top_layout.addWidget(self.max_lines_spin)
    top_layout.addSpacing(10)
    top_layout.addWidget(self.current_lines_label)
    top_layout.addSpacing(20)
    top_layout.addWidget(line_top_2)
    top_layout.addSpacing(20)
    top_layout.addWidget(self.Address_label)
    top_layout.addSpacing(5)
    top_layout.addWidget(self.Transaction_time_label)

    top_layout.addStretch()

    layout.addWidget(top_widget)

    splitter = QSplitter(Qt.Orientation.Vertical)
    splitter.setStyleSheet(&#34;&#34;&#34;
        QSplitter::handle {
            background: transparent;
            border    : none;
            min-height: 5px;
        }
        QSplitter::handle:vertical {
            height: 5px;
        }
        QSplitter::handle:horizontal {
            width: 5px;
        }
    &#34;&#34;&#34;)
    
    self.create_display_area(splitter)
    
    bottom_widget = QWidget()
    # bottom_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.25);&#34;)
    bottom_layout = QHBoxLayout(bottom_widget)
    
    self.clear_btn = QPushButton(&#34;æ¸…å±&#34;)
    self.clear_btn.setFixedWidth(80)
    self.clear_btn.clicked.connect(self.serial_display.clear)

    self.config_highlight_btn = QPushButton(&#34;é«˜äº®&#34;)
    self.config_highlight_btn.setFixedWidth(80)
    self.config_highlight_btn.clicked.connect(self.open_highlight_config_dialog)

    self.timestamp = QCheckBox(&#34;ğŸ•’ æ—¶é—´æˆ³&#34;)
    self.timestamp.setObjectName(&#34;timestamp&#34;)
    self.timestamp.setToolTip(&#34;æ¯è¡Œå‰æ·»åŠ æ—¶é—´æˆ³&#34;)
    self.timestamp.setChecked(True)
    self.auto_scroll = QCheckBox(&#34;ğŸ“Œ è‡ªåŠ¨æ»šåŠ¨&#34;)
    self.auto_scroll.setObjectName(&#34;autoScroll&#34;)
    self.auto_scroll.setChecked(False)
    self.auto_scroll.setToolTip(&#34;é”å®šæ»šåŠ¨æ¡åˆ°åº•éƒ¨&#34;)

    line_bottom_1 = QFrame()
    line_bottom_1.setFrameShape(QFrame.Shape.VLine)
    line_bottom_1.setFrameShadow(QFrame.Shadow.Sunken)
    line_bottom_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

    line_bottom_2 = QFrame()
    line_bottom_2.setFrameShape(QFrame.Shape.VLine)
    line_bottom_2.setFrameShadow(QFrame.Shadow.Sunken)
    line_bottom_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

    # æ—¥å¿—ç›¸å…³æŒ‰é’®
    self.open_csv_log_file_btn = QPushButton(&#34;ğŸ“„CSV&#34;)
    self.open_csv_log_file_btn.setFixedWidth(75)
    self.open_csv_log_file_btn.setToolTip(&#34;æ‰“å¼€å½“å‰CSVæ—¥å¿—æ–‡ä»¶&#34;)
    self.open_csv_log_file_btn.clicked.connect(self.open_current_csv_file)
    self.open_csv_log_file_btn.setEnabled(False)

    self.open_text_log_file_btn = QPushButton(&#34;ğŸ“„TEXT&#34;)
    self.open_text_log_file_btn.setFixedWidth(75)
    self.open_text_log_file_btn.setToolTip(&#34;æ‰“å¼€å½“å‰Textæ—¥å¿—æ–‡ä»¶&#34;)
    self.open_text_log_file_btn.clicked.connect(self.open_current_text_log_file)
    self.open_text_log_file_btn.setEnabled(False)

    self.open_log_folder_btn = QPushButton(&#34;ğŸ“&#34;)
    self.open_log_folder_btn.setFixedWidth(60)
    self.open_log_folder_btn.setToolTip(&#34;æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹&#34;)
    self.open_log_folder_btn.clicked.connect(self.open_log_folder)

    bottom_layout.addWidget(self.clear_btn)
    bottom_layout.addWidget(self.config_highlight_btn)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(line_bottom_1)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(self.timestamp)
    bottom_layout.addWidget(self.auto_scroll)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(line_bottom_2)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(self.open_csv_log_file_btn)
    bottom_layout.addWidget(self.open_text_log_file_btn)
    bottom_layout.addWidget(self.open_log_folder_btn)
    bottom_layout.addStretch()
    
    splitter.addWidget(bottom_widget)
    splitter.setSizes([2000, 100])  # è®¾ç½®åˆå§‹å¤§å°æ¯”ä¾‹
    
    layout.addWidget(splitter)
    
    # è®¾ç½®è‡ªåŠ¨æ‰«æå®šæ—¶å™¨
    self.port_scan_timer = QTimer()
    self.port_scan_timer.timeout.connect(self.refresh_ports)
    self.port_scan_timer.start(1000)
    self.refresh_ports()
    
    return COM1_page</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_COM_page2"><code class="name flex">
<span>def <span class="ident">create_COM_page2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_COM_page2(self):
    COM2_page = QWidget()
    layout = QVBoxLayout(COM2_page)
    layout.setContentsMargins(10, 10, 10, 10)
    layout.setSpacing(10)
    
    top_widget = QWidget()
    top_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.2);&#34;)
    top_layout = QHBoxLayout(top_widget)
    top_layout.setContentsMargins(5, 5, 5, 5)
    
    self.port_combo2 = QComboBox()
    self.port_combo2.setMinimumWidth(120)

    self.baud_combo2 = QComboBox()
    self.baud_combo2.addItems([&#39;9600&#39;, &#39;115200&#39;, &#39;230400&#39;, &#39;460800&#39;, &#39;3000000&#39;])
    self.baud_combo2.setCurrentText(&#39;3000000&#39;)
    self.baud_combo2.setStyleSheet(self.port_combo2.styleSheet())

    status_widget = QWidget()
    status_layout = QHBoxLayout(status_widget)
    status_layout.setContentsMargins(10, 0, 10, 0)
    status_layout.setSpacing(5)
    self.status_indicator2 = QLabel(&#34;â—&#34;)
    self.status_indicator2.setStyleSheet(&#34;color: red; font-size: 16px;background:rgba(36, 42, 56, 0);&#34;)
    status_layout.addWidget(self.status_indicator2)

    self.toggle_btn2 = QPushButton(&#34;æ‰“å¼€ä¸²å£&#34;)
    self.toggle_btn2.setFixedWidth(90)
    self.toggle_btn2.clicked.connect(self.toggle_port2)

    line_top_1 = QFrame()
    line_top_1.setFrameShape(QFrame.Shape.VLine)
    line_top_1.setFrameShadow(QFrame.Shadow.Sunken)
    line_top_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)
    
    max_lines_label = QLabel(&#34;æœ€å¤§è¡Œæ•°&#34;)
    max_lines_label.setStyleSheet(&#34;background: rgba(36, 42, 56, 0);&#34;)
    self.max_lines_spin2 = QSpinBox()
    self.max_lines_spin2.setRange(50000, 300000)
    self.max_lines_spin2.setValue(150000)
    self.max_lines_spin2.setSingleStep(10000)
    self.max_lines_spin2.valueChanged.connect(self.update_max_lines2)
    self.current_lines_label2 = QLabel(&#34;å½“å‰è¡Œæ•°: 0&#34;)
    self.current_lines_label2.setStyleSheet(&#34;background: rgba(36, 42, 56, 0);&#34;)
    
    line_top_2 = QFrame()
    line_top_2.setFrameShape(QFrame.Shape.VLine)
    line_top_2.setFrameShadow(QFrame.Shadow.Sunken)
    line_top_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

    self.Address_label_2 = QLabel(&#34;0000  -&#34;)
    self.Address_label_2.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
   
    self.Transaction_time_label_2 = QLabel(&#34;0000ms&#34;)
    self.Transaction_time_label_2.setStyleSheet(&#34;background:rgba(36, 42, 56, 0);&#34;)
    
    top_layout.addWidget(self.port_combo2)
    top_layout.addSpacing(10)
    top_layout.addWidget(self.baud_combo2)
    top_layout.addSpacing(10)
    top_layout.addWidget(status_widget)
    top_layout.addWidget(self.toggle_btn2)
    top_layout.addSpacing(20)
    top_layout.addWidget(line_top_1)
    top_layout.addSpacing(20)
    top_layout.addWidget(max_lines_label)
    top_layout.addWidget(self.max_lines_spin2)
    top_layout.addSpacing(10)
    top_layout.addWidget(self.current_lines_label2)
    top_layout.addSpacing(20)
    top_layout.addWidget(line_top_2)
    top_layout.addSpacing(20)
    top_layout.addWidget(self.Address_label_2)
    top_layout.addSpacing(5)
    top_layout.addWidget(self.Transaction_time_label_2)
    top_layout.addStretch()

    layout.addWidget(top_widget)

    splitter = QSplitter(Qt.Orientation.Vertical)
    splitter.setStyleSheet(&#34;&#34;&#34;
        QSplitter::handle {
            background: transparent;
            border    : none;
            min-height: 5px;
        }
        QSplitter::handle:vertical {
            height: 5px;
        }
        QSplitter::handle:horizontal {
            width: 5px;
        }
    &#34;&#34;&#34;)
    
    self.create_display_area2(splitter)

    bottom_widget = QWidget()
    # bottom_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0.8);&#34;)
    bottom_layout = QHBoxLayout(bottom_widget)
    
    self.clear_btn2 = QPushButton(&#34;æ¸…å±&#34;)
    self.clear_btn2.setFixedWidth(80)
    self.clear_btn2.clicked.connect(self.serial_display2.clear)

    self.config_highlight_btn2 = QPushButton(&#34;é«˜äº®&#34;)
    self.config_highlight_btn2.setFixedWidth(80)
    self.config_highlight_btn2.clicked.connect(self.open_highlight_config_dialog)

    self.timestamp2 = QCheckBox(&#34;ğŸ•’ æ—¶é—´æˆ³&#34;)
    self.timestamp2.setObjectName(&#34;timestamp&#34;)
    self.timestamp2.setToolTip(&#34;æ¯è¡Œå‰æ·»åŠ æ—¶é—´æˆ³&#34;)
    self.timestamp2.setChecked(True)
    self.auto_scroll2 = QCheckBox(&#34;ğŸ“Œ è‡ªåŠ¨æ»šåŠ¨&#34;)
    self.auto_scroll2.setObjectName(&#34;autoScroll&#34;)
    self.auto_scroll2.setChecked(False)
    self.auto_scroll2.setToolTip(&#34;é”å®šæ»šåŠ¨æ¡åˆ°åº•éƒ¨&#34;)

    line_bottom_1 = QFrame()
    line_bottom_1.setFrameShape(QFrame.Shape.VLine)
    line_bottom_1.setFrameShadow(QFrame.Shadow.Sunken)
    line_bottom_1.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

    line_bottom_2 = QFrame()
    line_bottom_2.setFrameShape(QFrame.Shape.VLine)
    line_bottom_2.setFrameShadow(QFrame.Shadow.Sunken)
    line_bottom_2.setStyleSheet(&#34;color: #66abf5; background: #4a90e2; min-width:1px;&#34;)

    # æ—¥å¿—ç›¸å…³æŒ‰é’®
    self.open_text_log_file_btn2 = QPushButton(&#34;ğŸ“„TEXT&#34;)
    self.open_text_log_file_btn2.setFixedWidth(75)
    self.open_text_log_file_btn2.setToolTip(&#34;æ‰“å¼€å½“å‰Textæ—¥å¿—æ–‡ä»¶&#34;)
    self.open_text_log_file_btn2.clicked.connect(self.open_current_text_log_file2)
    self.open_text_log_file_btn2.setEnabled(False)

    self.open_log_folder_btn2 = QPushButton(&#34;ğŸ“&#34;)
    self.open_log_folder_btn2.setFixedWidth(60)
    self.open_log_folder_btn2.setToolTip(&#34;æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹&#34;)
    self.open_log_folder_btn2.clicked.connect(self.open_log_folder)

    bottom_layout.addWidget(self.clear_btn2)
    bottom_layout.addWidget(self.config_highlight_btn2)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(line_bottom_1)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(self.timestamp2)
    bottom_layout.addWidget(self.auto_scroll2)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(line_bottom_2)
    bottom_layout.addSpacing(10)
    bottom_layout.addWidget(self.open_text_log_file_btn2)
    bottom_layout.addWidget(self.open_log_folder_btn2)
    bottom_layout.addStretch()
    
    splitter.addWidget(bottom_widget)
    splitter.setSizes([2000, 100])  
    
    layout.addWidget(splitter)
    
    self.port_scan_timer2 = QTimer()
    self.port_scan_timer2.timeout.connect(self.refresh_ports2)
    self.port_scan_timer2.start(1000)
    self.refresh_ports2()
    
    return COM2_page</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_Chart_page"><code class="name flex">
<span>def <span class="ident">create_Chart_page</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_Chart_page(self):
    Chart_page = QWidget()
    layout = QVBoxLayout(Chart_page)
    layout.setContentsMargins(0, 0, 0, 0)
    layout.setSpacing(0)

    main_splitter = QSplitter(Qt.Orientation.Vertical)
    main_splitter.setStyleSheet(&#34;&#34;&#34;
        QSplitter::handle {
            background: transparent;
            border    : none;
            min-height: 5px;
        }
        QSplitter::handle:vertical {
            height: 5px;
        }
        QSplitter::handle:horizontal {
            width: 5px;
        }
    &#34;&#34;&#34;)
    chart_widget = self.create_chart_area()
    main_splitter.addWidget(chart_widget)

    canvas_splitter = QSplitter(Qt.Orientation.Horizontal)
    canvas_splitter.setStyleSheet(&#34;&#34;&#34;
        QSplitter::handle {
            background: transparent;
            border    : none;
            min-height: 5px;
        }
        QSplitter::handle:vertical {
            height: 5px;
        }
        QSplitter::handle:horizontal {
            width: 5px;
        }
    &#34;&#34;&#34;)

    table_widget = self.create_test_area()  # è¿™é‡ŒåŒ…å«äº†è¡¨æ ¼å’Œé¢„ç•™åŒºåŸŸ
    canvas_splitter.addWidget(table_widget)
    position_widget = self.create_position_area()
    canvas_splitter.addWidget(position_widget)

    canvas_splitter.setSizes([100, 100])
    main_splitter.addWidget(canvas_splitter)
    main_splitter.setSizes([100, 200])

    layout.addWidget(main_splitter)
    return Chart_page</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_chart_area"><code class="name flex">
<span>def <span class="ident">create_chart_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_chart_area(self):
    top_widget = QWidget()
    top_widget.setStyleSheet(&#34;background: rgba(36, 42, 56, 0);&#34;)
    top_layout = QHBoxLayout(top_widget)
    top_layout.setContentsMargins(5, 5, 5, 5)
    top_layout.setSpacing(10)

    self.charts  = {}
    self.series  = {}
    chart_titles = {
        &#39;master&#39;   : &#39;Master&#39;,
        &#39;slave&#39;    : &#39;Slave&#39;,
        &#39;nlos&#39;     : &#39;NLOS&#39;,
        &#39;lift_deep&#39;: &#39;RSSI&#39;,
        &#39;speed&#39;    : &#39;Speed&#39;
    }
    for key, title in chart_titles.items():
        series = QLineSeries()
        colors = {
            &#39;master&#39;   : QColor(&#34;#FF6B6B&#34;),
            &#39;slave&#39;    : QColor(&#34;#4ECDC4&#34;),
            &#39;nlos&#39;     : QColor(&#34;#45B7D1&#34;),
            &#39;lift_deep&#39;: QColor(&#34;#68ecae&#34;),
            &#39;speed&#39;    : QColor(&#34;#FFBE0B&#34;)
        }
        series.setColor(colors[key])
        series.setPen(QPen(colors[key], 3))   # æ›²çº¿åŠ ç²—
        series.setPointsVisible(False)        # æ˜¾ç¤ºæ•°æ®ç‚¹
        series.setPointLabelsVisible(False)   # æ˜¾ç¤ºç‚¹æ ‡ç­¾ï¼ˆå¯é€‰ï¼‰
        series.setPointLabelsColor(colors[key].darker(150))
        self.series[key] = series

        chart = QChart()
        chart.addSeries(series)
        chart.setTitle(title)
        chart.setTitleFont(QFont(&#34;Segoe UI&#34;, 12, QFont.Weight.Bold))
        chart.setTitleBrush(colors[key].darker(120))
        chart.setAnimationOptions(QChart.AnimationOption.SeriesAnimations)
        chart.legend().hide()
        
        # ä¼˜åŒ–æ¸å˜èƒŒæ™¯ - æ›´ä¸°å¯Œçš„æ¸å˜æ•ˆæœ
        gradient = QLinearGradient(0, 0, 0, 1)
        gradient.setCoordinateMode(QLinearGradient.CoordinateMode.ObjectBoundingMode)
        gradient.setColorAt(0.0, QColor(60, 62, 68, 150))   # é¡¶éƒ¨é¢œè‰²å¢å¼º
        gradient.setColorAt(0.3, QColor(50, 52, 60, 100))   # æ·»åŠ ä¸­é—´è¿‡æ¸¡è‰²
        gradient.setColorAt(0.7, QColor(40, 42, 50, 70))    # æ·»åŠ ä¸­é—´è¿‡æ¸¡è‰²
        gradient.setColorAt(1.0, QColor(32, 34, 38, 40))    # åº•éƒ¨é¢œè‰²å¾®è°ƒ
        chart.setBackgroundBrush(gradient)
        chart.setBackgroundRoundness(12)        # å¢åŠ åœ†è§’
        chart.setMargins(QMargins(8, 10, 8, 8)) # è°ƒæ•´è¾¹è·
        
        # ä¼˜åŒ–é˜´å½±æ•ˆæœ
        chart.setDropShadowEnabled(True)
        # è¾¹æ¡†ç¾åŒ–
        chart.setBackgroundPen(QPen(QColor(140, 150, 180, 70), 1.2))
        
        # Xè½´ç¾åŒ–
        axis_x = QValueAxis()
        axis_x.setRange(0, 100)
        axis_x.setLabelFormat(&#34;%d&#34;)
        axis_x.setLabelsColor(QColor(&#34;#E5E9F0&#34;).lighter(110))  # ç¨å¾®æäº®æ ‡ç­¾
        axis_x.setGridLineVisible(True)
        axis_x.setGridLineColor(QColor(255, 255, 255, 30))     # é™ä½ç½‘æ ¼çº¿ä¸é€æ˜åº¦
        axis_x.setMinorGridLineVisible(True)
        axis_x.setMinorGridLineColor(QColor(255, 255, 255, 15))
        axis_x.setLabelsFont(QFont(&#34;Segoe UI&#34;, 9))
        # axis_x.setTitleText(&#34;æ•°æ®ç‚¹&#34;)                          # æ·»åŠ è½´æ ‡é¢˜
        axis_x.setTitleFont(QFont(&#34;Segoe UI&#34;, 9, QFont.Weight.Medium))
        axis_x.setTitleBrush(QColor(&#34;#E5E9F0&#34;))
        
        # Yè½´ç¾åŒ–
        axis_y = QValueAxis()
        axis_y.setRange(-10, 10)
        axis_y.setLabelFormat(&#34;%d&#34;)
        axis_y.setLabelsColor(QColor(&#34;#E5E9F0&#34;).lighter(110))  # ç¨å¾®æäº®æ ‡ç­¾
        axis_y.setGridLineVisible(True)
        axis_y.setGridLineColor(QColor(255, 255, 255, 30))     # é™ä½ç½‘æ ¼çº¿ä¸é€æ˜åº¦
        axis_y.setMinorGridLineVisible(True)
        axis_y.setMinorGridLineColor(QColor(255, 255, 255, 15))
        axis_y.setLabelsFont(QFont(&#34;Segoe UI&#34;, 9))
        # axis_y.setTitleText(&#34;æ•°å€¼&#34;)                            # æ·»åŠ è½´æ ‡é¢˜
        axis_y.setTitleFont(QFont(&#34;Segoe UI&#34;, 9, QFont.Weight.Medium))
        axis_y.setTitleBrush(QColor(&#34;#E5E9F0&#34;))
        
        chart.addAxis(axis_x, Qt.AlignmentFlag.AlignBottom)
        chart.addAxis(axis_y, Qt.AlignmentFlag.AlignLeft)
        series.attachAxis(axis_x)
        series.attachAxis(axis_y)
        
        # ç¾åŒ–çº¿æ¡
        if isinstance(series, QLineSeries):
            pen = series.pen()
            pen.setWidth(2)                                  # å¢åŠ çº¿å®½
            series.setPen(pen)
        
        chart_view = QChartView(chart)
        chart_view.setRenderHint(QPainter.RenderHint.Antialiasing)
        chart_view.setStyleSheet(&#34;&#34;&#34;
            background   : transparent;
            border-radius: 14px;                               /* å¢åŠ è¾¹æ¡†åœ†è§’ */
            margin       : 2px;                                /* æ·»åŠ è¾¹è· */
        &#34;&#34;&#34;)

        # é¼ æ ‡æ‚¬åœæ˜¾ç¤ºæ•°æ®ç‚¹å€¼
        def show_tooltip(point, state, key=key):
            if state:
                QToolTip.showText(QCursor.pos(), f&#34;{chart_titles[key]}: {int(point.y())}&#34;)
            else:
                QToolTip.hideText()
        series.hovered.connect(show_tooltip)

        self.charts[key] = chart
        top_layout.addWidget(chart_view)
    return top_widget</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_display_area"><code class="name flex">
<span>def <span class="ident">create_display_area</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_display_area(self, layout):
    &#34;&#34;&#34;åˆ›å»ºæ•°æ®æ˜¾ç¤ºåŒºåŸŸ&#34;&#34;&#34;
    self.serial_display = QTextEdit()
    self.serial_display.setReadOnly(True)
    self.serial_display.document().setMaximumBlockCount(150000)  # é™åˆ¶æœ€å¤§è¡Œæ•°
    self.serial_display.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)  # è‡ªåŠ¨æ¢è¡Œ
    self.serial_display.setWordWrapMode(QTextOption.WrapMode.WrapAnywhere)  # å…è®¸åœ¨ä»»ä½•ä½ç½®æ¢è¡Œ
    self.serial_display.installEventFilter(self) # å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨
    
    # ä¼˜åŒ–æ˜¾ç¤ºæ€§èƒ½
    self.serial_display.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    self.serial_display.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    self.serial_display.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
    
    # è®¾ç½®å­—ä½“å’Œæ ·å¼
    font = QFont(&#34;Microsoft YaHei&#34;, 12)
    self.serial_display.setFont(font)
    
    self.serial_display.setStyleSheet(&#34;&#34;&#34;
        QTextEdit {
            background-color          : rgba(36, 42, 56, 0.177);
            border                    : 1.5px solid #3a4a5c;
            border-radius             : 16px;
            padding                   : 12px;
            color                     : {theme[&#39;text&#39;]};
            font-size                 : 15px;
            font-family               : &#39;JetBrains Mono&#39;, &#39;Consolas&#39;, &#39;Microsoft YaHei&#39;, monospace;
            selection-background-color: #088bef;
            selection-color           : #ffffff;

        }
        QTextEdit:focus {
            border          : 1.5px solid #477faa;
            background-color: rgba(36, 42, 56, 0.5);
        }
    &#34;&#34;&#34;)
    
    # æ›´æ–°åˆå§‹è¡Œæ•°æ˜¾ç¤º
    self.serial_display.document().blockCountChanged.connect(self.update_current_lines)
    self.update_current_lines()

    # æŸ¥æ‰¾æ¡†ç›¸å…³
    self.find_dialog = QDialog(self)
    self.find_dialog.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
    self.find_dialog.setFixedSize(300, 48)
    self.find_dialog.setStyleSheet(&#34;&#34;&#34;
        QDialog {
            background-color: rgba(45, 52, 54, 0.95);
            border          : 1px solid rgba(255, 255, 255, 0.1);
            border-radius   : 10px;
        }
    &#34;&#34;&#34;)

    find_layout = QHBoxLayout(self.find_dialog)
    find_layout.setContentsMargins(6, 6, 6, 6)
    find_layout.setSpacing(6)

    self.find_input = QLineEdit()
    self.find_input.setPlaceholderText(&#34;è¾“å…¥æœç´¢å†…å®¹&#34;)
    self.find_input.textChanged.connect(self.update_find_count)
    self.count_label = QLabel(&#34;0/0&#34;)

    # ä¸Šä¸‹ç®­å¤´æŒ‰é’®
    from PyQt6.QtWidgets import QToolButton
    self.prev_btn = QToolButton()
    self.prev_btn.setArrowType(Qt.ArrowType.UpArrow)
    self.prev_btn.clicked.connect(lambda: self.find_text(False))
    self.next_btn = QToolButton()
    self.next_btn.setArrowType(Qt.ArrowType.DownArrow)
    self.next_btn.clicked.connect(lambda: self.find_text(True))

    # å…³é—­æŒ‰é’®
    self.close_find_btn = QToolButton()
    self.close_find_btn.setText(&#34;âœ•&#34;)
    self.close_find_btn.clicked.connect(self.find_dialog.close)
    self.close_find_btn.setStyleSheet(&#34;font-size: 16px; color: #fff; background: transparent; border: none;&#34;)

    find_layout.addWidget(self.find_input)
    find_layout.addWidget(self.count_label)
    find_layout.addWidget(self.prev_btn)
    find_layout.addWidget(self.next_btn)
    find_layout.addWidget(self.close_find_btn)

    # æ·»åŠ é¼ æ ‡äº‹ä»¶å¤„ç†
    self.serial_display.wheelEvent = self.on_display_wheel
    self.serial_display.keyPressEvent = self.on_display_key_press
    self.font_size = 12  # åˆå§‹å­—ä½“å¤§å°
    
    layout.addWidget(self.serial_display)</code></pre>
</details>
<div class="desc"><p>åˆ›å»ºæ•°æ®æ˜¾ç¤ºåŒºåŸŸ</p></div>
</dd>
<dt id="UWBDash.MainWindow.create_display_area2"><code class="name flex">
<span>def <span class="ident">create_display_area2</span></span>(<span>self, layout)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_display_area2(self, layout):
    self.serial_display2 = QTextEdit()
    self.serial_display2.setReadOnly(True)
    self.serial_display2.setFocusPolicy(Qt.FocusPolicy.StrongFocus) # ç¡®ä¿èƒ½æ¥æ”¶é”®ç›˜äº‹ä»¶
    self.serial_display2.installEventFilter(self) # å®‰è£…äº‹ä»¶è¿‡æ»¤å™¨
    self.serial_display2.document().setMaximumBlockCount(150000)  # é™åˆ¶æœ€å¤§è¡Œæ•°
    self.serial_display2.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)  # è‡ªåŠ¨æ¢è¡Œ
    self.serial_display2.setWordWrapMode(QTextOption.WrapMode.WrapAnywhere)  # å…è®¸åœ¨ä»»ä½•ä½ç½®æ¢è¡Œ
    
    self.serial_display2.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    self.serial_display2.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAsNeeded)
    self.serial_display2.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
    
    font = QFont(&#34;Microsoft YaHei&#34;, 12)
    self.serial_display2.setFont(font)
    
    self.serial_display2.setStyleSheet(&#34;&#34;&#34;
        QTextEdit {
            background-color          : rgba(36, 42, 56, 0.177);
            border                    : 1.5px solid #3a4a5c;
            border-radius             : 16px;
            padding                   : 12px;
            color                     : {theme[&#39;text&#39;]};
            font-size                 : 15px;
            font-family               : &#39;JetBrains Mono&#39;, &#39;Consolas&#39;, &#39;Microsoft YaHei&#39;, monospace;
            selection-background-color: #088bef;
            selection-color           : #ffffff;

        }
        QTextEdit:focus {
            border          : 1.5px solid #477faa;
            background-color: rgba(36, 42, 56, 0.5);
        }
        QScrollBar:vertical {
            background   : transparent;
            width        : 10px;
            margin       : 2px 0 2px 0;
            border-radius: 5px;
        }
        QScrollBar::handle:vertical {
            background: qlineargradient(
                x1:0, y1:0, x2:1, y2:1,
                stop:0 #3da9fc, stop:1 #1e293b
            );
            min-height   : 24px;
            border-radius: 5px;
        }
        QScrollBar::handle:vertical:hover {
            background: qlineargradient(
                x1:0, y1:0, x2:1, y2:1,
                stop:0 #90caf9, stop:1 #3da9fc
            );
        }
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            height    : 0;
            background: none;
            border    : none;
        }
    &#34;&#34;&#34;)
    
    self.serial_display2.document().blockCountChanged.connect(self.update_current_lines2)
    self.update_current_lines2()

    self.find_dialog2 = QDialog(self)
    self.find_dialog2.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
    self.find_dialog2.setFixedSize(300, 48)
    self.find_dialog2.setStyleSheet(&#34;&#34;&#34;
        QDialog {
            background-color: rgba(45, 52, 54, 0.95);
            border          : 1px solid rgba(255, 255, 255, 0.1);
            border-radius   : 10px;
        }
    &#34;&#34;&#34;)

    find_layout = QHBoxLayout(self.find_dialog2)
    find_layout.setContentsMargins(6, 6, 6, 6)
    find_layout.setSpacing(6)

    self.find_input2 = QLineEdit()
    self.find_input2.setPlaceholderText(&#34;è¾“å…¥æœç´¢å†…å®¹&#34;)
    self.find_input2.textChanged.connect(self.update_find_count2)
    self.count_label2 = QLabel(&#34;0/0&#34;)

    from PyQt6.QtWidgets import QToolButton
    self.prev_btn2 = QToolButton()
    self.prev_btn2.setArrowType(Qt.ArrowType.UpArrow)
    self.prev_btn2.clicked.connect(lambda: self.find_text2(False))
    self.next_btn2 = QToolButton()
    self.next_btn2.setArrowType(Qt.ArrowType.DownArrow)
    self.next_btn2.clicked.connect(lambda: self.find_text2(True))

    self.close_find_btn2 = QToolButton()
    self.close_find_btn2.setText(&#34;âœ•&#34;)
    self.close_find_btn2.clicked.connect(self.find_dialog2.close)
    self.close_find_btn2.setStyleSheet(&#34;font-size: 16px; color: #fff; background: transparent; border: none;&#34;)

    find_layout.addWidget(self.find_input2)
    find_layout.addWidget(self.count_label2)
    find_layout.addWidget(self.prev_btn2)
    find_layout.addWidget(self.next_btn2)
    find_layout.addWidget(self.close_find_btn2)

    self.serial_display2.keyPressEvent = self.on_display_key_press2
    # self.serial_display2.setTextInteractionFlags(Qt.TextInteractionFlag.NoTextInteraction)
    
    layout.addWidget(self.serial_display2)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_nav_bar"><code class="name flex">
<span>def <span class="ident">create_nav_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_nav_bar(self):
    nav_container = QWidget()
    nav_container.setMinimumWidth(65)  
    nav_container.setMaximumWidth(300) 
    nav_layout = QVBoxLayout(nav_container)
    nav_layout.setContentsMargins(0, 0, 0, 0)
    nav_layout.setSpacing(0)

    self.nav_list = QListWidget()
    self.nav_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
    self.nav_list.setFocusPolicy(Qt.FocusPolicy.NoFocus)
    
    nav_items = [&#34;COM 1&#34;, &#34;COM 2&#34;, &#34;CHART&#34;] 
    for item in nav_items:
        list_item = QListWidgetItem(item)
        list_item.setFont(QFont(&#34;Segoe UI&#34;, 10, QFont.Weight.Bold))
        list_item.setSizeHint(QSize(65, 50))
        list_item.setTextAlignment(Qt.AlignmentFlag.AlignVCenter)
        self.nav_list.addItem(list_item)

    self.theme_btn = QPushButton(&#34; ğŸŒ“ &#34;)
    # self.theme_btn.setFixedHeight(45)
    self.theme_btn.setStyleSheet(f&#34;background: {self.current_theme[&#39;bg&#39;]}; border-radius: 0px;&#34;)
    self.theme_btn.clicked.connect(self.toggle_theme)

    nav_layout.addWidget(self.nav_list)
    nav_layout.addWidget(self.theme_btn)
    return nav_container</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_pages"><code class="name flex">
<span>def <span class="ident">create_pages</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_pages(self):
    COM1_page  = self.create_COM_page()
    COM2_page  = self.create_COM_page2()
    Chart_page = self.create_Chart_page()

    self.stacked_widget.addWidget(COM1_page)
    self.stacked_widget.addWidget(COM2_page)
    self.stacked_widget.addWidget(Chart_page)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_position_area"><code class="name flex">
<span>def <span class="ident">create_position_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_position_area(self):
    bottom_right = QWidget()
    bottom_right_layout = QVBoxLayout(bottom_right)
    bottom_right_layout.setContentsMargins(5, 5, 5, 5)
    self.position_view = PositionView()
    bottom_right_layout.addWidget(self.position_view)
    # bottom_right.setStyleSheet(&#34;background-color: rgba(255, 255, 255, 0.1); border-radius: 5px;&#34;)
    return bottom_right</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_test_area"><code class="name flex">
<span>def <span class="ident">create_test_area</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_test_area(self):
    bottom_left = QWidget()
    bottom_left.setStyleSheet(&#34;background-color: rgba(45, 52, 54,  0.15); &#34;)
    bottom_left_layout = QVBoxLayout(bottom_left)
    bottom_left_layout.setContentsMargins(0, 0, 0, 0)
    bottom_left.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

    form_splitter = QSplitter(Qt.Orientation.Vertical)
    form_splitter.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

    # ä¸Šéƒ¨åˆ† - æ•°æ®è¡¨æ ¼
    top_table = QWidget()
    top_table_layout = QVBoxLayout(top_table)
    top_table_layout.setContentsMargins(5, 5, 5, 5)
    top_table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)

    self.data_table = QTableWidget()
    self.data_table.setColumnCount(10)
    self.data_table.setHorizontalHeaderLabels([
        &#39;Master&#39;, &#39;Slave&#39;, &#39;NLOS&#39;, &#39;RSSI&#39;, &#39;Speed&#39;,
        &#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;Auth&#39;, &#39;Trans&#39;
    ])
    
    self.data_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
    self.data_table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
    top_table_layout.addWidget(self.data_table)

    # ä¸‹éƒ¨åˆ† - Test åŒºåŸŸ
    bottom_space = QWidget()
    # bottom_space.setStyleSheet(&#34;background: rgba(255, 255, 255, 0.05);&#34;)


    form_splitter.addWidget(top_table)
    form_splitter.addWidget(bottom_space)
    form_splitter.setSizes([100, 0])

    bottom_left_layout.addWidget(form_splitter)
    return bottom_left</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.create_title_bar"><code class="name flex">
<span>def <span class="ident">create_title_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_title_bar(self):
    title_bar = QWidget()
    title_bar.setObjectName(&#34;titleBar&#34;)
    title_bar.setFixedHeight(30)
    title_layout = QHBoxLayout(title_bar)
    title_layout.setContentsMargins(10, 0, 10, 0)
    title_layout.setSpacing(5)

    def mousePressEvent(event):
        if event.button() == Qt.MouseButton.LeftButton:
            self.drag_pos = event.globalPosition().toPoint()
    
    def mouseMoveEvent(event):
        if event.buttons() &amp; Qt.MouseButton.LeftButton:
            self.move(self.pos() + event.globalPosition().toPoint() - self.drag_pos)
            self.drag_pos = event.globalPosition().toPoint()
    
    # å°†äº‹ä»¶å¤„ç†å™¨ç»‘å®šåˆ°æ ‡é¢˜æ 
    title_bar.mousePressEvent = mousePressEvent
    title_bar.mouseMoveEvent  = mouseMoveEvent

    title_bar.setAttribute(Qt.WidgetAttribute.WA_MouseTracking)
    
    self.title_label = QLabel(&#34;UWBDash&#34;)
    self.title_label.setObjectName(&#34;titleLabel&#34;)
    
    help_btn = QPushButton(&#34;Help&#34;)
    help_btn.setStyleSheet(&#34;background: transparent; border: none;color:#c29500;font-weight:bold;&#34;)
    help_btn.clicked.connect(self.show_help_dialog)
    
    about_btn = QPushButton(&#34;About&#34;)
    about_btn.setStyleSheet(&#34;background: transparent; border: none;color:#c29500;font-weight:bold;&#34;)
    about_btn.clicked.connect(self.show_about_dialog)

    btn_size = QSize(20, 20)
    
    minimize_btn = QPushButton(&#34;â”€&#34;)
    minimize_btn.setFixedSize(btn_size)
    minimize_btn.clicked.connect(self.showMinimized)
    
    self.maximize_btn = QPushButton(&#34;â–¡&#34;)
    self.maximize_btn.setFixedSize(btn_size)
    self.maximize_btn.clicked.connect(self.toggle_maximize)
    
    close_btn = QPushButton(&#34;âŒ&#34;)
    close_btn.setFixedSize(btn_size)
    close_btn.clicked.connect(self.close)

    control_btns = [minimize_btn, self.maximize_btn, close_btn]
    for btn in control_btns:
        btn.setStyleSheet(&#34;&#34;&#34;
            QPushButton {
                border    : none;
                font-size : 10px;
                padding   : 5px;
                background: transparent;
            }
            QPushButton:hover {
                background-color: rgba(255, 255, 255, 0.1);
            }
        &#34;&#34;&#34;)
    close_btn.setStyleSheet(close_btn.styleSheet() + &#34;&#34;&#34;
        QPushButton:hover {
            background-color: #ff4444;
        }
    &#34;&#34;&#34;)

    title_layout.addWidget(self.title_label)
    title_layout.addWidget(help_btn)
    title_layout.addWidget(about_btn)
    title_layout.addStretch()
    title_layout.addWidget(minimize_btn)
    title_layout.addWidget(self.maximize_btn)
    title_layout.addWidget(close_btn)
    
    return title_bar</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.eventFilter"><code class="name flex">
<span>def <span class="ident">eventFilter</span></span>(<span>self, obj, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eventFilter(self, obj, event):
    if (obj == self.serial_display or obj == self.serial_display2) and event.type() == QEvent.Type.Wheel:
        print(f&#34;Event type: {event.type()}&#34;)
        self.wheelEvent(event)
        return True # é˜»æ­¢äº‹ä»¶è¿›ä¸€æ­¥ä¼ æ’­
    return super().eventFilter(obj, event)</code></pre>
</details>
<div class="desc"><p>eventFilter(self, a0: Optional[QObject], a1: Optional[QEvent]) -&gt; bool</p></div>
</dd>
<dt id="UWBDash.MainWindow.find_text"><code class="name flex">
<span>def <span class="ident">find_text</span></span>(<span>self, forward=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_text(self, forward=True):
    text = self.find_input.text()
    if not text:
        return
    
    # ç»ˆæ­¢ä¸Šä¸€ä¸ªæŸ¥æ‰¾çº¿ç¨‹
    if hasattr(self, &#39;find_thread&#39;) and self.find_thread.isRunning():
        self.find_thread.terminate()
        self.find_thread.wait()
    
    self.auto_scroll.setChecked(True)

    content = self.serial_display.toPlainText()
    cursor  = self.serial_display.textCursor()
    cur_pos = cursor.selectionStart() if cursor.hasSelection() else cursor.position()

    # å¯åŠ¨æŸ¥æ‰¾çº¿ç¨‹
    self.find_thread = FindThread(content, text, cur_pos, forward)
    self.find_thread.result_ready.connect(self.on_find_result)
    self.find_thread.start()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.find_text2"><code class="name flex">
<span>def <span class="ident">find_text2</span></span>(<span>self, forward=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_text2(self, forward=True):
    &#34;&#34;&#34;å¢é‡æŸ¥æ‰¾æ–‡æœ¬&#34;&#34;&#34;
    text = self.find_input2.text()
    if not text:
        return
    
    # ç»ˆæ­¢ä¸Šä¸€ä¸ªæŸ¥æ‰¾çº¿ç¨‹
    if hasattr(self, &#39;find_thread2&#39;) and self.find_thread2.isRunning():
        self.find_thread2.terminate()
        self.find_thread2.wait()
    
    doc = self.serial_display2.document()
    current_format = doc.defaultTextOption()

    self.auto_scroll2.setChecked(True)

    content = self.serial_display2.toPlainText()
    cursor = self.serial_display2.textCursor()
    cur_pos = cursor.selectionStart() if cursor.hasSelection() else cursor.position()

    # å¯åŠ¨æŸ¥æ‰¾çº¿ç¨‹
    self.find_thread2 = FindThread(content, text, cur_pos, forward)
    self.find_thread2.result_ready.connect(self.on_find_result2)
    self.find_thread2.start()</code></pre>
</details>
<div class="desc"><p>å¢é‡æŸ¥æ‰¾æ–‡æœ¬</p></div>
</dd>
<dt id="UWBDash.MainWindow.handle_serial_2_data"><code class="name flex">
<span>def <span class="ident">handle_serial_2_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_serial_2_data(self, data):
    try:
        text = data.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;)
        self.log_worker.add_log_task(&#34;UwbLog2&#34;, &#34;info&#34;, text.strip())
        text = re.sub(r&#39;\x1b\[[0-9;]*[a-zA-Z]&#39;, &#39;&#39;, text)

        if &#34;@@@ Time of Write Card End&#34; in text:
            #&#34;@@@ Time of Write Card End     = 00:14:520  â”‚ 80D7 â”‚  710 ms&#34;
            match = re.search(r&#34;â”‚\s*([0-9A-Fa-f]+)\s*â”‚\s*(\d+)\s*ms&#34;, text)
            if match:
                address = match.group(1)
                transaction_time = match.group(2)
                
                if hasattr(self, &#39;Address_label_2&#39;) and self.Address_label_2 is not None:
                    self.Address_label_2.setText(f&#34;{address}  -&#34;)
                
                if hasattr(self, &#39;Transaction_time_label_2&#39;) and self.Transaction_time_label_2 is not None:
                    self.Transaction_time_label_2.setText(f&#34;{transaction_time}ms&#34;)

        self.data_buffer2.append(text)
    except Exception as e:
        print(f&#34;æ•°æ®å¤„ç†é”™è¯¯ (on_data_received): {str(e)}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.handle_serial_data"><code class="name flex">
<span>def <span class="ident">handle_serial_data</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_serial_data(self, data):
    try:
        text = data.decode(&#39;utf-8&#39;)
        
        self.log_worker.add_log_task(&#34;UwbLog&#34;, &#34;info&#34;, text.strip())
        text = re.sub(r&#39;\x1b\[[0-9;]*[a-zA-Z]&#39;, &#39;&#39;, text)
        self.data_buffer.append(text)

        if &#34;@@@ Time of Write Card End&#34; in text:
            #&#34;@@@ Time of Write Card End     = 00:14:520  â”‚ 80D7 â”‚  710 ms&#34;
            match = re.search(r&#34;â”‚\s*([0-9A-Fa-f]+)\s*â”‚\s*(\d+)\s*ms&#34;, text)
            if match:
                address = match.group(1)
                transaction_time = match.group(2)
                
                if hasattr(self, &#39;Address_label&#39;) and self.Address_label is not None:
                    self.Address_label.setText(f&#34;{address}  -&#34;)
                
                if hasattr(self, &#39;Transaction_time_label&#39;) and self.Transaction_time_label is not None:
                    self.Transaction_time_label.setText(f&#34;{transaction_time}ms&#34;)
        
        if &#34;@POSITION&#34; in text:
            # print(f&#39;æ¥æ”¶åˆ°åŸå§‹æ•°æ®ï¼š{repr(text)}&#39;)
            try:
                json_data = json.loads(text)
            except json.JSONDecodeError as e:
                print(f&#34;JSONè§£æé”™è¯¯: {e}&#34;)
                return
            # æå–ç”¨æˆ·åæ ‡
            user_x = float(json_data.get(&#39;User-X&#39;, 0))
            user_y = float(json_data.get(&#39;User-Y&#39;, 0))
            user_z = float(json_data.get(&#39;User-Z&#39;, 0))
            
            # Map JSON keys to chart keys
            key_mapping = {
                &#39;master&#39;   : &#39;Master&#39;,
                &#39;slave&#39;    : &#39;Slave&#39;,
                &#39;nlos&#39;     : &#39;nLos&#39;,
                &#39;lift_deep&#39;: &#39;LiftDeep&#39;,
                &#39;speed&#39;    : &#39;Speed&#39;
            }
            
            # Update data with correct key mapping
            for chart_key, json_key in key_mapping.items():
                try:
                    value = int(json_data.get(json_key, 0))
                    self.uwb_data[chart_key].append(value)

                    if len(self.uwb_data[chart_key]) &gt; 100:
                        self.uwb_data[chart_key] = self.uwb_data[chart_key][-100:]
                    
                    self.chart_thread.add_data(chart_key, value)
                        
                except (ValueError, TypeError):
                    continue

            # Log data
            data_values = [
                json_data.get(&#39;Master&#39;, 0),
                json_data.get(&#39;Slave&#39;, 0),
                json_data.get(&#39;nLos&#39;, 0),
                json_data.get(&#39;LiftDeep&#39;, 0),
                json_data.get(&#39;Speed&#39;, 0),
                json_data.get(&#39;User-X&#39;, 0),
                json_data.get(&#39;User-Y&#39;, 0),
                json_data.get(&#39;User-Z&#39;, 0),
                json_data.get(&#39;Auth&#39;, 0),
                json_data.get(&#39;Trans&#39;, 0)
            ]
            
            # å†™å…¥CSV
            csv_data = &#34;,&#34;.join(str(val) for val in data_values)
            self.log_worker.add_log_task(&#34;data&#34;, &#34;info&#34;, csv_data)
            
            # ç¼“å­˜è¡¨æ ¼æ•°æ®ï¼Œå»¶åæ‰¹é‡æ’å…¥
            if not hasattr(self, &#39;pending_table_rows&#39;):
                self.pending_table_rows = []
            self.pending_table_rows.append(data_values)

            # æ›´æ–°ç”¨æˆ·ä½ç½®æ˜¾ç¤ºï¼ˆä»…å½“æœ‰æ˜æ˜¾åç§»æ—¶ï¼‰
            if hasattr(self, &#39;position_view&#39;):
                last_pos = getattr(self.position_view, &#34;current_position&#34;, None)
                threshold = 2  # ä¾‹å¦‚5ç±³æˆ–5åƒç´ ï¼Œæ ¹æ®ä½ çš„scaleè°ƒæ•´
                if last_pos is None or ((user_x - last_pos[0]) ** 2 + (user_y - last_pos[1]) ** 2) ** 0.5 &gt; threshold:
                    self.position_view.update_position(user_x, user_y)
                    
    except Exception as e:
        print(f&#34;Error processing serial data: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.init_ui"><code class="name flex">
<span>def <span class="ident">init_ui</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_ui(self):
    title_bar = self.create_title_bar()
    self.setGeometry(100, 100, 800, 700)

    main_widget = QWidget()
    self.setCentralWidget(main_widget)
    main_layout = QVBoxLayout(main_widget)
    main_layout.setContentsMargins(0, 0, 0, 0)
    main_layout.setSpacing(0)

    nav_container = self.create_nav_bar()
    self.nav_list.currentRowChanged.connect(self.switch_page)

    self.stacked_widget = QStackedWidget()
    self.create_pages()

    splitter = QSplitter(Qt.Orientation.Horizontal)
    splitter.setStyleSheet(&#34;&#34;&#34;
        QSplitter::handle {
            background: transparent;
            border    : none;
            min-height: 2px;
        }
        QSplitter::handle:vertical {
            height: 2px;
        }
        QSplitter::handle:horizontal {
            width: 2px;
        }
    &#34;&#34;&#34;)
    
    splitter.addWidget(nav_container)
    splitter.addWidget(self.stacked_widget)
    splitter.setStretchFactor(1, 1)  
    splitter.setSizes([80,500])

    main_layout.addWidget(title_bar)
    main_layout.addWidget(splitter)  
    
    self.apply_theme()
    self.nav_list.setCurrentRow(0)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.load_highlight_config"><code class="name flex">
<span>def <span class="ident">load_highlight_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_highlight_config(self):
    try:
        with open(self.highlight_config_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as f:
            data = json.load(f)
        # å°†é¢œè‰²å­—ç¬¦ä¸²è½¬ä¸º QColor
        return {k: QColor(v) for k, v in data.items()}
    except Exception as e:
        print(f&#34;åŠ è½½é«˜äº®é…ç½®å¤±è´¥: {e}&#34;)
        # é»˜è®¤é…ç½®
        return {
            &#34;APP     :ERROR&#34;     : QColor(&#34;#ff7f7f&#34;),
            &#34;APP     :INFO&#34;      : QColor(&#34;#8ccfff&#34;),
            &#34;APP     :WARN&#34;      : QColor(&#34;#ffd280&#34;),
            &#34;gCapSessionHandle&#34;  : QColor(&#34;#00ff7f&#34;),
            &#34;gDtxSessionHandle&#34;  : QColor(&#34;#b9f309&#34;),
            &#34;gMrmSessionHandle&#34;  : QColor(&#34;#ffaaff&#34;),
            &#34;AuthenticationState&#34;: QColor(&#34;#3daaea&#34;),
            &#34;APP_HIFTask&#34;        : QColor(&#34;#34a7b2&#34;),
        }</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.mousePressEvent"><code class="name flex">
<span>def <span class="ident">mousePressEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mousePressEvent(self, event):
    idx = self.stacked_widget.currentIndex()
    count = self.stacked_widget.count()
    print(f&#34;count: {count} idx: {idx}&#34;)
    if event.button() == Qt.MouseButton.XButton2:  
        new_idx = (idx - 1) % count
        self.stacked_widget.setCurrentIndex(new_idx)
        self.nav_list.setCurrentRow(new_idx)
        print(f&#34;New_idx: {new_idx}&#34;)
    elif event.button() == Qt.MouseButton.XButton1:  
        new_idx = (idx + 1) % count
        self.stacked_widget.setCurrentIndex(new_idx)
        self.nav_list.setCurrentRow(new_idx)
        print(f&#34;New_idx: {new_idx}&#34;)
    else:
        super().mousePressEvent(event)</code></pre>
</details>
<div class="desc"><p>mousePressEvent(self, a0: Optional[QMouseEvent])</p></div>
</dd>
<dt id="UWBDash.MainWindow.on_display_key_press"><code class="name flex">
<span>def <span class="ident">on_display_key_press</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_display_key_press(self, event):
    &#34;&#34;&#34;å¤„ç†æ˜¾ç¤ºåŒºåŸŸçš„é”®ç›˜äº‹ä»¶&#34;&#34;&#34;
    if event.key() == Qt.Key.Key_Space:
        self.auto_scroll.setChecked(not self.auto_scroll.isChecked())
    elif event.modifiers() == Qt.KeyboardModifier.ControlModifier and event.key() == Qt.Key.Key_F:
        # è®¡ç®—æŸ¥æ‰¾æ¡†æ˜¾ç¤ºåœ¨serial_displayå³ä¸Šè§’
        parent_pos = self.serial_display.mapToGlobal(self.serial_display.rect().topRight())
        dlg_geom = self.find_dialog.geometry()

        cursor = self.serial_display.textCursor()
        selected_text = cursor.selectedText()
        # è®©æŸ¥æ‰¾æ¡†å³ä¸Šè§’ä¸æ˜¾ç¤ºåŒºå³ä¸Šè§’å¯¹é½
        self.find_dialog.move(parent_pos.x() - dlg_geom.width(), parent_pos.y())
        self.find_dialog.show()
        self.find_input.setFocus()
        self.find_input.selectAll()
        self.auto_scroll.setChecked(True)
        if selected_text:
            self.find_input.setText(selected_text)
    # è°ƒç”¨åŸå§‹çš„é”®ç›˜äº‹ä»¶å¤„ç†
    QTextEdit.keyPressEvent(self.serial_display, event)</code></pre>
</details>
<div class="desc"><p>å¤„ç†æ˜¾ç¤ºåŒºåŸŸçš„é”®ç›˜äº‹ä»¶</p></div>
</dd>
<dt id="UWBDash.MainWindow.on_display_key_press2"><code class="name flex">
<span>def <span class="ident">on_display_key_press2</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_display_key_press2(self, event):
    if event.key() == Qt.Key.Key_Space:
        self.auto_scroll2.setChecked(not self.auto_scroll2.isChecked())
    elif event.modifiers() &amp; Qt.KeyboardModifier.ControlModifier:
        if event.key() == Qt.Key.Key_F:
            cursor = self.serial_display2.textCursor()
            selected_text = cursor.selectedText()
            self.show_find_dialog2()
            if selected_text:
                self.find_input2.setText(selected_text)
                self.find_input2.selectAll()
            event.accept()
            return
    
    QTextEdit.keyPressEvent(self.serial_display2, event)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.on_display_wheel"><code class="name flex">
<span>def <span class="ident">on_display_wheel</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_display_wheel(self, event):
    &#34;&#34;&#34;å¤„ç†æ˜¾ç¤ºåŒºåŸŸçš„é¼ æ ‡æ»šè½®äº‹ä»¶&#34;&#34;&#34;
    if event.modifiers() == Qt.KeyboardModifier.ControlModifier:
        delta = event.angleDelta().y()
        if delta &gt; 0:
            self.font_size = min(self.font_size + 1, 24)  # å¢å¤§å­—ä½“ï¼Œæœ€å¤§24
        else:
            self.font_size = max(self.font_size - 1, 8)   # å‡å°å­—ä½“ï¼Œæœ€å°8
        
        # æ›´æ–°å­—ä½“å¤§å°
        self.serial_display.setStyleSheet(f&#34;&#34;&#34;
            QTextEdit {{
                background-color: rgba(0, 0, 0, 0.2);
                border          : 1px solid rgba(255, 255, 255, 0.1);
                border-radius   : 10px;
                padding         : 10px;
                color           : #fafafa;
                font-family     : &#39;Consolas&#39;, &#39;Courier New&#39;, monospace;
                font-size       : {self.font_size}px;
            }}
        &#34;&#34;&#34;)
    else:
        # è°ƒç”¨åŸå§‹çš„æ»šè½®äº‹ä»¶å¤„ç†
        QTextEdit.wheelEvent(self.serial_display, event)</code></pre>
</details>
<div class="desc"><p>å¤„ç†æ˜¾ç¤ºåŒºåŸŸçš„é¼ æ ‡æ»šè½®äº‹ä»¶</p></div>
</dd>
<dt id="UWBDash.MainWindow.on_find_result"><code class="name flex">
<span>def <span class="ident">on_find_result</span></span>(<span>self, current, total, positions)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_find_result(self, current, total, positions):
    # å®šä½å¹¶é«˜äº®å½“å‰åŒ¹é…é¡¹
    pos    = positions[current]
    length = len(self.find_input.text())
    cursor = self.serial_display.textCursor()
    cursor.setPosition(pos)
    cursor.setPosition(pos + length, QTextCursor.MoveMode.KeepAnchor)
    self.serial_display.setTextCursor(cursor)

    fmt = QTextCharFormat()
    fmt.setBackground(QColor(&#34;#c3dd8c&#34;))
    fmt.setForeground(QColor(&#34;#000000&#34;))
    fmt.setFontWeight(QFont.Weight.Bold)
    cursor.mergeCharFormat(fmt)

    self._last_highlight = (pos, length)
    self.count_label.setText(f&#34;{current+1}/{total}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.on_find_result2"><code class="name flex">
<span>def <span class="ident">on_find_result2</span></span>(<span>self, current, total, positions)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_find_result2(self, current, total, positions):
    # å®šä½å¹¶é«˜äº®å½“å‰åŒ¹é…é¡¹
    pos = positions[current]
    length = len(self.find_input2.text())
    cursor = self.serial_display2.textCursor()
    cursor.setPosition(pos)
    cursor.setPosition(pos + length, QTextCursor.MoveMode.KeepAnchor)
    self.serial_display2.setTextCursor(cursor)

    fmt = QTextCharFormat()
    fmt.setBackground(QColor(&#34;#ffaaff&#34;))
    fmt.setForeground(QColor(&#34;#000000&#34;))
    fmt.setFontWeight(QFont.Weight.Bold)
    cursor.mergeCharFormat(fmt)

    self._last_highlight2 = (pos, length)
    self.count_label2.setText(f&#34;{current+1}/{total}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.open_current_csv_file"><code class="name flex">
<span>def <span class="ident">open_current_csv_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_current_csv_file(self):
    &#34;&#34;&#34;ä½¿ç”¨ç³»ç»Ÿé»˜è®¤åº”ç”¨æ‰“å¼€å½“å‰çš„æ—¥å¿—æ–‡ä»¶&#34;&#34;&#34;
    if self.current_csv_log_file_path and os.path.exists(self.current_csv_log_file_path):
        try:
            os.startfile(self.current_csv_log_file_path) # Windows specific
        except Exception as e:
            QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€æ—¥å¿—æ–‡ä»¶ï¼š\n{e}&#34;)
    else:
        QMessageBox.information(self, &#34;æç¤º&#34;, &#34;å½“å‰æ²¡æœ‰æ´»åŠ¨çš„æ—¥å¿—æ–‡ä»¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚&#34;)</code></pre>
</details>
<div class="desc"><p>ä½¿ç”¨ç³»ç»Ÿé»˜è®¤åº”ç”¨æ‰“å¼€å½“å‰çš„æ—¥å¿—æ–‡ä»¶</p></div>
</dd>
<dt id="UWBDash.MainWindow.open_current_text_log_file"><code class="name flex">
<span>def <span class="ident">open_current_text_log_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_current_text_log_file(self):
    &#34;&#34;&#34;ä½¿ç”¨ç³»ç»Ÿé»˜è®¤åº”ç”¨æ‰“å¼€å½“å‰çš„ Text æ—¥å¿—æ–‡ä»¶&#34;&#34;&#34;
    if self.current_text_log_file_path and os.path.exists(self.current_text_log_file_path):
        try:
            os.startfile(self.current_text_log_file_path) # Windows specific
        except Exception as e:
            QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€ Text æ—¥å¿—æ–‡ä»¶ï¼š\n{e}&#34;)
    else:
        QMessageBox.information(self, &#34;æç¤º&#34;, &#34;å½“å‰æ²¡æœ‰æ´»åŠ¨çš„ Text æ—¥å¿—æ–‡ä»¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚&#34;)</code></pre>
</details>
<div class="desc"><p>ä½¿ç”¨ç³»ç»Ÿé»˜è®¤åº”ç”¨æ‰“å¼€å½“å‰çš„ Text æ—¥å¿—æ–‡ä»¶</p></div>
</dd>
<dt id="UWBDash.MainWindow.open_current_text_log_file2"><code class="name flex">
<span>def <span class="ident">open_current_text_log_file2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_current_text_log_file2(self):
    if self.current_text_log_file_path2 and os.path.exists(self.current_text_log_file_path2):
        try:
            os.startfile(self.current_text_log_file_path2) # Windows specific
        except Exception as e:
            QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€ Text æ—¥å¿—æ–‡ä»¶ï¼š\n{e}&#34;)
    else:
        QMessageBox.information(self, &#34;æç¤º&#34;, &#34;å½“å‰æ²¡æœ‰æ´»åŠ¨çš„ Text æ—¥å¿—æ–‡ä»¶æˆ–æ–‡ä»¶ä¸å­˜åœ¨ã€‚&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.open_highlight_config_dialog"><code class="name flex">
<span>def <span class="ident">open_highlight_config_dialog</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_highlight_config_dialog(self):
    dialog = HighlightConfigDialog(self.highlight_config, self)
    if dialog.exec() == QDialog.DialogCode.Accepted:
        self.highlight_config = dialog.get_config()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.open_log_folder"><code class="name flex">
<span>def <span class="ident">open_log_folder</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_log_folder(self):
    &#34;&#34;&#34;ä½¿ç”¨ç³»ç»Ÿæ–‡ä»¶æµè§ˆå™¨æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹&#34;&#34;&#34;
    log_dir = getattr(self.logger, &#39;log_dir&#39;, None)
    if log_dir and os.path.isdir(log_dir):
        try:
            os.startfile(log_dir) # Windows specific
            return 
        except Exception as e:
            QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€æ—¥å¿—ç›®å½• &#39;{log_dir}&#39;ï¼š\n{e}&#34;)

    # å¦‚æœ logger æ²¡æœ‰ log_dir æˆ–ç›®å½•ä¸å­˜åœ¨ï¼Œå¯ä»¥å°è¯•æ‰“å¼€ç¨‹åºè¿è¡Œç›®å½•ä¸‹çš„ &#39;UWBLogs&#39; æ–‡ä»¶å¤¹
    fallback_dir = os.path.join(os.path.dirname(__file__), &#39;UWBLogs&#39;) 
    if os.path.isdir(fallback_dir):
         try:
            os.startfile(fallback_dir)
         except Exception as e:
            QMessageBox.warning(self, &#34;æ‰“å¼€å¤±è´¥&#34;, f&#34;æ— æ³•æ‰“å¼€å¤‡é€‰æ—¥å¿—ç›®å½• &#39;{fallback_dir}&#39;ï¼š\n{e}&#34;)
    else:
        QMessageBox.warning(self, &#34;é”™è¯¯&#34;, &#34;æ— æ³•ç¡®å®šæ—¥å¿—ç›®å½•ï¼Œä¸»ç›®å½•å’Œå¤‡é€‰ç›®å½•å‡æœªæ‰¾åˆ°ã€‚&#34;)</code></pre>
</details>
<div class="desc"><p>ä½¿ç”¨ç³»ç»Ÿæ–‡ä»¶æµè§ˆå™¨æ‰“å¼€æ—¥å¿—æ–‡ä»¶å¤¹</p></div>
</dd>
<dt id="UWBDash.MainWindow.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event):
    if not self.background_cache or self.size() != self.last_window_size:
        size = self.size()
        background_path = Path(__file__).parent / self.background_image
        if not background_path.exists(): # Fallback if current image is somehow invalid
            print(f&#34;Warning: Background image {self.background_image} not found. Falling back to default.&#34;)
            if self.background_images:
                self.background_image = self.background_images[0]
                self._save_background_config() # Save the fallback
                background_path = Path(__file__).parent / self.background_image
            else: # Ultimate fallback if list is also empty (should not happen with proper config loading)
                # You might want to handle this case more gracefully, e.g., by not drawing a background
                # or using a solid color. For now, let&#39;s assume config loading ensures a valid image.
                print(&#34;Error: No background images available.&#34;)
                return # Or handle error appropriately

        background = QPixmap(str(background_path))
        self.background_cache = background.scaled(
            size, 
            Qt.AspectRatioMode.KeepAspectRatioByExpanding,
            Qt.TransformationMode.SmoothTransformation
        )
        self.last_window_size = size
        
    painter = QPainter(self) 
    painter.setOpacity(1)
    x = (self.width() - self.background_cache.width()) // 2
    y = (self.height() - self.background_cache.height()) // 2
    painter.drawPixmap(x, y, self.background_cache)</code></pre>
</details>
<div class="desc"><p>paintEvent(self, a0: Optional[QPaintEvent])</p></div>
</dd>
<dt id="UWBDash.MainWindow.refresh_ports"><code class="name flex">
<span>def <span class="ident">refresh_ports</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_ports(self):
    &#34;&#34;&#34;åˆ·æ–°å¯ç”¨ä¸²å£åˆ—è¡¨&#34;&#34;&#34;
    try:
        from serial.tools import list_ports
        ports = [port.device for port in list_ports.comports()]
        if set(ports) == set(self.current_ports):
            return
            
        current_port = self.port_combo.currentText()
        
        self.current_ports = ports
        self.port_combo.clear()
        for port in ports:
            self.port_combo.addItem(port)
        
        # æ¢å¤ä¹‹å‰é€‰æ‹©çš„ä¸²å£
        if current_port:
            index = self.port_combo.findText(current_port)
            if index &gt;= 0:
                self.port_combo.setCurrentIndex(index)
                
    except Exception as e:
        print(f&#34;è·å–ä¸²å£åˆ—è¡¨å¤±è´¥: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"><p>åˆ·æ–°å¯ç”¨ä¸²å£åˆ—è¡¨</p></div>
</dd>
<dt id="UWBDash.MainWindow.refresh_ports2"><code class="name flex">
<span>def <span class="ident">refresh_ports2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_ports2(self):
    import serial.tools.list_ports
    current_port = self.port_combo2.currentText() if self.port_combo2.count() &gt; 0 else &#34;&#34;
    ports = list(serial.tools.list_ports.comports())
    available_ports = [port.device for port in ports]
    if set(available_ports) != set(self.current_ports2):
        self.port_combo2.clear()
        for port in ports:
            self.port_combo2.addItem(port.device)
        if current_port and self.port_combo2.findText(current_port) &gt;= 0:
            self.port_combo2.setCurrentText(current_port)
        self.current_ports2 = available_ports</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.reload_highlight_config"><code class="name flex">
<span>def <span class="ident">reload_highlight_config</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reload_highlight_config(self):
    # å°†å½“å‰çš„ self.highlight_config å†™å›åˆ° JSON æ–‡ä»¶
    try:
        data = {k: v.name() for k, v in self.highlight_config.items()}
        with open(self.highlight_config_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as f:
            json.dump(data, f, ensure_ascii=False, indent=4)
    except Exception as e:
        print(f&#34;ä¿å­˜é«˜äº®é…ç½®å¤±è´¥: {e}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.show_about_dialog"><code class="name flex">
<span>def <span class="ident">show_about_dialog</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_about_dialog(self):
    QMessageBox.about(self, &#34;å…³äº&#34;, &#34;UWBDash APP\nCardShare@QLL&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.show_find_dialog2"><code class="name flex">
<span>def <span class="ident">show_find_dialog2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_find_dialog2(self):
    display_rect = self.serial_display2.rect()
    display_pos = self.serial_display2.mapToGlobal(display_rect.topRight())
    dialog_x = display_pos.x() - self.find_dialog2.width() - 10  # è·ç¦»å³è¾¹ç•Œ10åƒç´ 
    dialog_y = display_pos.y() + 10  # è·ç¦»é¡¶éƒ¨10åƒç´ 
    self.find_dialog2.move(dialog_x, dialog_y)
    
    self.find_dialog2.show()
    self.find_input2.setFocus()
    self.find_input2.selectAll()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.show_help_dialog"><code class="name flex">
<span>def <span class="ident">show_help_dialog</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_help_dialog(self):
    help_dialog = QDialog(self)
    help_dialog.setWindowTitle(&#34;UWBDash Help&#34;)
    help_dialog.setFixedSize(500, 400)

    layout = QVBoxLayout(help_dialog)

    title_label = QLabel(&#34;UWBDash Help Guide&#34;)
    title_label.setStyleSheet(&#34;font-size: 24px; font-weight: bold; color: #c29500;&#34;)
    title_label.setAlignment(Qt.AlignmentFlag.AlignCenter)

    # Create a scroll area for the content
    scroll = QScrollArea()
    scroll.setWidgetResizable(True)
    scroll_content = QWidget()
    scroll_layout = QVBoxLayout(scroll_content)

    # Add help sections
    sections = [
        (&#34;Basic Controls&#34;, [
            &#34;â€¢ Click and drag the title bar to move the window&#34;,
            &#34;â€¢ Ctrl + F to open the search box&#34;,
            &#34;â€¢ Select the message box and press Space to stop the scrolling&#34;
        ]),
        (&#34;Data Visualization&#34;, [
            &#34;â€¢ Slave anchor needs to be connected for transmitting json data&#34;,
            &#34;â€¢ Real-time UWB positioning data display&#34;,
            &#34;â€¢ Interactive charts for key param monitoring&#34;,
        ]),
        (&#34;Configuration&#34;, [
            &#34;â€¢ Set up serial port parameters in the settings panel&#34;,
            &#34;â€¢ Customize highlight colors for different message types&#34;
        ]),
        (&#34;Logging&#34;, [
            &#34;â€¢ A log file will be created automatically in the app directory when the &#39;æ‰“å¼€ä¸²å£&#39; button is clicked every time&#34;,
        ])
    ]

    for section_title, items in sections:
        section_label = QLabel(section_title)
        section_label.setStyleSheet(&#34;font-size: 16px; font-weight: bold; color: #666; margin-top: 10px;&#34;)
        scroll_layout.addWidget(section_label)

        for item in items:
            item_label = QLabel(item)
            # item_label.setStyleSheet(&#34;font-size: 12px; color: #333; margin-left: 20px;&#34;)
            item_label.setWordWrap(True)
            scroll_layout.addWidget(item_label)

    scroll_layout.addStretch()
    scroll.setWidget(scroll_content)
    layout.addWidget(title_label)
    layout.addWidget(scroll)

    # Add OK button
    ok_button = QPushButton(&#34;OK&#34;)
    ok_button.clicked.connect(help_dialog.accept)
    layout.addWidget(ok_button)
    help_dialog.exec()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.switch_page"><code class="name flex">
<span>def <span class="ident">switch_page</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switch_page(self, index):
    self.stacked_widget.setCurrentIndex(index)
    if index != 0:  
        self.find_dialog.close()
    if index != 1:
        self.find_dialog2.close()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.theme_changed"><code class="name flex">
<span>def <span class="ident">theme_changed</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="UWBDash.MainWindow.toggle_maximize"><code class="name flex">
<span>def <span class="ident">toggle_maximize</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_maximize(self):
    if self.isMaximized():
        self.showNormal()
        self.maximize_btn.setText(&#34;â–¡&#34;)
    else:
        self.showMaximized()
        self.maximize_btn.setText(&#34;â&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.toggle_port"><code class="name flex">
<span>def <span class="ident">toggle_port</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_port(self):
    &#34;&#34;&#34;åˆ‡æ¢ä¸²å£å¼€å…³çŠ¶æ€&#34;&#34;&#34;
    if self.toggle_btn.text() == &#34;æ‰“å¼€ä¸²å£&#34;:
        try:
            # åˆ›å»ºä¸²å£å¯¹è±¡
            self.serial_port = serial.Serial(
                port     = self.port_combo.currentText(),
                baudrate = int(self.baud_combo.currentText()),
                bytesize = self.data_bits,
                parity   = self.parity,
                stopbits = self.stop_bits,
                timeout  = 0.1
            )
            
            # åˆ›å»ºå¹¶å¯åŠ¨è¯»å–çº¿ç¨‹
            self.serial_thread = SerialReadThread(self.serial_port)
            self.serial_thread.data_received.connect(self.handle_serial_data)
            self.serial_thread.start()
            
            # æ›´æ–°UIçŠ¶æ€
            self.toggle_btn.setText(&#34;å…³é—­ä¸²å£&#34;)
            self.status_indicator.setStyleSheet(&#34;color: green;background:rgba(36,36,36,0);&#34;)

            current_time      = datetime.datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
            port_name         = self.port_combo.currentText().replace(&#34;:&#34;, &#34;_&#34;)
            csv_log_filename  = f&#34;[{port_name}] {current_time}.csv&#34;
            text_log_filename = f&#34;[{port_name}] {current_time}.log&#34;

            # ç¡®ä¿ logger å®ä¾‹åŠå…¶ç›®å½•å±æ€§å­˜åœ¨
            if hasattr(self.logger, &#39;csv_log_dir&#39;) and hasattr(self.logger, &#39;text_log_dir&#39;):
                self.current_csv_log_file_path = os.path.join(self.logger.csv_log_dir, csv_log_filename)
                self.current_text_log_file_path = os.path.join(self.logger.text_log_dir, text_log_filename)
                self.logger.create_logger(&#34;data&#34;, csv_log_filename, &#34;csv&#34;) # åˆ›å»º CSV æ—¥å¿—
                header_str = &#34;,&#34;.join(self.csv_title)
                self.log_worker.add_log_task(&#34;data&#34;, &#34;info&#34;, header_str)
                self.logger.create_logger(&#34;UwbLog&#34;, text_log_filename, &#34;text&#34;) # åˆ›å»º Text æ—¥å¿—
                self.open_csv_log_file_btn.setEnabled(True) # å¯ç”¨æŒ‰é’®
                self.open_text_log_file_btn.setEnabled(True)
            else:
                # å¦‚æœæ— æ³•è·å– log_dirï¼Œåˆ™ç¦ç”¨æŒ‰é’®å¹¶æ‰“å°è­¦å‘Š
                print(&#34;è­¦å‘Š: Logger å¯¹è±¡ç¼ºå°‘ csv_log_dir æˆ– text_log_dir å±æ€§ï¼Œ&#39;æ‰“å¼€æ—¥å¿—æ–‡ä»¶&#39;åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚&#34;)
                self.current_csv_log_file_path  = None
                self.current_text_log_file_path = None
                self.open_csv_log_file_btn.setEnabled(False)
        except Exception as e:
            QMessageBox.critical(self, &#34;é”™è¯¯&#34;, f&#34;æ‰“å¼€ä¸²å£å¤±è´¥ï¼š{str(e)}&#34;)
            self.current_csv_log_file_path  = None 
            self.current_text_log_file_path = None
            self.open_csv_log_file_btn.setEnabled(False)
            return
    else:
        # å…³é—­ä¸²å£
        if hasattr(self, &#39;serial_thread&#39;):
            self.serial_thread.stop()
        if hasattr(self, &#39;serial_port&#39;):
            self.serial_port.close()
        
        # æ›´æ–°UIçŠ¶æ€
        self.toggle_btn.setText(&#34;æ‰“å¼€ä¸²å£&#34;)
        self.status_indicator.setStyleSheet(&#34;color: red;background:rgba(36,42,56,0);&#34;)</code></pre>
</details>
<div class="desc"><p>åˆ‡æ¢ä¸²å£å¼€å…³çŠ¶æ€</p></div>
</dd>
<dt id="UWBDash.MainWindow.toggle_port2"><code class="name flex">
<span>def <span class="ident">toggle_port2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_port2(self):
    if self.toggle_btn2.text() == &#34;æ‰“å¼€ä¸²å£&#34;:
        try:
            port = self.port_combo2.currentText()
            if not port:
                raise Exception(&#34;è¯·é€‰æ‹©ä¸²å£&#34;)
                
            baud = int(self.baud_combo2.currentText())
            self.serial2 = serial.Serial(
                port     = port,
                baudrate = baud,
                bytesize = self.data_bits,
                parity   = self.parity,
                stopbits = self.stop_bits,
                timeout  = 0.1
            )
            
            if not self.serial2.is_open:
                self.serial2.open()
            
            self.serial_thread2 = SerialReadThread(self.serial2)
            self.serial_thread2.data_received.connect(self.handle_serial_2_data)
            self.serial_thread2.start()
            
            self.toggle_btn2.setText(&#34;å…³é—­ä¸²å£&#34;)
            self.status_indicator2.setStyleSheet(&#34;color: green;background:rgba(36,36,36,0);&#34;)
            
            current_time      = datetime.datetime.now().strftime(&#34;%Y%m%d_%H%M%S&#34;)
            port_name         = self.port_combo2.currentText().replace(&#34;:&#34;, &#34;_&#34;)
            text_log_filename = f&#34;[{port_name}] {current_time}.log&#34;

            # ç¡®ä¿ logger å®ä¾‹åŠå…¶ç›®å½•å±æ€§å­˜åœ¨
            if hasattr(self.logger, &#39;text_log_dir&#39;):
                self.current_text_log_file_path2 = os.path.join(self.logger.text_log_dir, text_log_filename)
                self.logger.create_logger(&#34;UwbLog2&#34;, text_log_filename, &#34;text&#34;) # åˆ›å»º Text æ—¥å¿—
                self.open_text_log_file_btn2.setEnabled(True)
            else:
                # å¦‚æœæ— æ³•è·å– log_dirï¼Œåˆ™ç¦ç”¨æŒ‰é’®å¹¶æ‰“å°è­¦å‘Š
                print(&#34;è­¦å‘Š: Logger å¯¹è±¡ç¼ºå°‘ csv_log_dir æˆ– text_log_dir å±æ€§ï¼Œ&#39;æ‰“å¼€æ—¥å¿—æ–‡ä»¶&#39;åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚&#34;)
                self.current_text_log_file_path2 = None
            
        except Exception as e:
            QMessageBox.warning(self, &#34;é”™è¯¯&#34;, f&#34;æ‰“å¼€ä¸²å£å¤±è´¥: {str(e)}&#34;)
    else:
        try:
            if hasattr(self, &#39;serial_thread2&#39;) and self.serial_thread2:
                self.serial_thread2.stop()
                self.serial_thread2 = None

            if hasattr(self, &#39;serial2&#39;) and self.serial2:
                self.serial2.close()
                self.serial2 = None
            
            self.toggle_btn2.setText(&#34;æ‰“å¼€ä¸²å£&#34;)
            self.status_indicator2.setStyleSheet(&#34;color: red;background:rgba(36,36,36,0);&#34;)
        except Exception as e:
            QMessageBox.warning(self, &#34;é”™è¯¯&#34;, f&#34;å…³é—­ä¸²å£å¤±è´¥: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.toggle_theme"><code class="name flex">
<span>def <span class="ident">toggle_theme</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_theme(self):
    self.background_image_index = (self.background_image_index + 1) % len(self.background_images)
    self.background_image = self.background_images[self.background_image_index]
    # åˆ‡æ¢èƒŒæ™¯å›¾ç‰‡å¹¶åˆ·æ–°
    background_path = Path(__file__).parent / self.background_image
    if background_path.exists():
        background = QPixmap(str(background_path))
        self.background_cache = background.scaled(
            self.size(),
            Qt.AspectRatioMode.KeepAspectRatioByExpanding,
            Qt.TransformationMode.SmoothTransformation
        )
        self.last_window_size = self.size()
    self._save_background_config()
    self.update()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.update_chart"><code class="name flex">
<span>def <span class="ident">update_chart</span></span>(<span>self, chart_key, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_chart(self, chart_key, value):
    &#34;&#34;&#34;æ›´æ–°å›¾è¡¨ï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œï¼‰&#34;&#34;&#34;
    try:
        series = self.series[chart_key]
        data_list = self.uwb_data[chart_key]
        
        # å¦‚æœç‚¹æ•°è¶…è¿‡100ï¼Œç§»é™¤æœ€æ—§çš„ç‚¹
        if series.count() &gt;= 100:
            series.remove(0)
        
        # æ›´æ–°æ‰€æœ‰ç‚¹çš„Xåæ ‡
        for i in range(series.count()):
            old_point = series.at(i)
            series.replace(i, QPointF(i, old_point.y()))
        
        # æ·»åŠ æ–°ç‚¹
        series.append(len(data_list) - 1, value)
        
        # æ›´æ–°Yè½´èŒƒå›´
        if data_list:
            min_val = min(data_list)
            max_val = max(data_list)
            margin  = (max_val - min_val) * 0.1 if max_val != min_val else 1.0
            chart   = self.charts[chart_key]
            y_axis  = chart.axes(Qt.Orientation.Vertical)[0]
            y_axis.setRange(min_val - margin, max_val + margin)
        
        data = self.uwb_data.get(chart_key, [])
        chart = self.charts[chart_key]

        if data:
            mean = sum(data) / len(data)
            std = (sum((x - mean) ** 2 for x in data) / len(data)) ** 0.5
            display_key = &#34;RSSI&#34; if chart_key == &#34;lift_deep&#34; else chart_key.upper()
            title = f&#34;{display_key} | Avg: {mean:.1f} | Std: {std:.1f}&#34;
        else:
            mean = 0
            std = 0
            title = chart_key.upper()
        chart.setTitle(title)

        n = len(data)
        # ===== å‡å€¼çº¿ =====
        if not hasattr(self, &#34;mean_series&#34;):
            self.mean_series = {}
        if chart_key not in self.mean_series:
            from PyQt6.QtCharts import QLineSeries
            mean_series = QLineSeries()
            mean_series.setColor(QColor(255, 255, 255))  # ç´«è‰²
            mean_series.setPen(QPen(QColor(255, 255, 255), 3, Qt.PenStyle.DashLine))  # å®çº¿åŠ ç²—
            chart.addSeries(mean_series)
            mean_series.attachAxis(chart.axes(Qt.Orientation.Horizontal)[0])
            mean_series.attachAxis(chart.axes(Qt.Orientation.Vertical)[0])
            self.mean_series[chart_key] = mean_series
        else:
            mean_series = self.mean_series[chart_key]
        mean_series.clear()
        if n &gt; 1:
            mean_series.append(0, mean)
            mean_series.append(n-1, mean)
        # ===== æ ‡å‡†å·®å¸¦ =====
        if not hasattr(self, &#34;std_area&#34;):
            self.std_area = {}
        if chart_key not in self.std_area:
            from PyQt6.QtCharts import QLineSeries, QAreaSeries
            upper = QLineSeries()
            lower = QLineSeries()
            area = QAreaSeries(upper, lower)
            area.setColor(QColor(0, 120, 255, 60))  # è“è‰²åŠé€æ˜
            area.setPen(QPen(QColor(0, 120, 255, 120), 1))
            chart.addSeries(area)
            area.attachAxis(chart.axes(Qt.Orientation.Horizontal)[0])
            area.attachAxis(chart.axes(Qt.Orientation.Vertical)[0])
            self.std_area[chart_key] = (upper, lower, area)
        else:
            upper, lower, area = self.std_area[chart_key]
        upper.clear()
        lower.clear()
        for i in range(n):
            upper.append(i, mean + std)
            lower.append(i, mean - std)

    except Exception as e:
        print(f&#34;Error updating chart: {str(e)}&#34;)</code></pre>
</details>
<div class="desc"><p>æ›´æ–°å›¾è¡¨ï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œï¼‰</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_current_lines"><code class="name flex">
<span>def <span class="ident">update_current_lines</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_current_lines(self):
    &#34;&#34;&#34;æ›´æ–°å½“å‰è¡Œæ•°æ˜¾ç¤º&#34;&#34;&#34;
    current_count = self.serial_display.document().blockCount()
    self.current_lines_label.setText(f&#34;å½“å‰è¡Œæ•°: {current_count}&#34;)
    # å¦‚æœå½“å‰è¡Œæ•°ç­‰äºæœ€å¤§è¡Œæ•°ï¼Œè‡ªåŠ¨æ¸…é™¤
    max_lines = self.serial_display.document().maximumBlockCount()
    if current_count &gt;= max_lines:
        self.serial_display.clear()</code></pre>
</details>
<div class="desc"><p>æ›´æ–°å½“å‰è¡Œæ•°æ˜¾ç¤º</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_current_lines2"><code class="name flex">
<span>def <span class="ident">update_current_lines2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_current_lines2(self):
    current_count = self.serial_display2.document().blockCount()
    self.current_lines_label2.setText(f&#34;å½“å‰è¡Œæ•°: {current_count}&#34;)
    max_lines = self.serial_display2.document().maximumBlockCount()
    if current_count &gt;= max_lines:
        self.serial_display2.clear()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.update_display"><code class="name flex">
<span>def <span class="ident">update_display</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_display(self):
    &#34;&#34;&#34;æ›´æ–°æ˜¾ç¤ºåŒºåŸŸ&#34;&#34;&#34;
    if self.data_buffer:
        cursor         = self.serial_display.textCursor()
        scrollbar      = self.serial_display.verticalScrollBar()
        current_scroll = scrollbar.value()
        
        text = &#39;&#39;.join(self.data_buffer)
        
        # å¦‚æœé€‰ä¸­äº†æ—¶é—´æˆ³é€‰é¡¹ï¼Œä¸ºæ¯è¡Œæ·»åŠ æ—¶é—´æˆ³
        if self.timestamp.isChecked():
            lines = text.splitlines(True) 
            timestamp = QDateTime.currentDateTime().toString(&#39;[yyyy-MM-dd hh:mm:ss.zzz] &#39;)
            text = &#39;&#39;.join(timestamp + line for line in lines)
        
        self.serial_display.setUpdatesEnabled(False)
        cursor.movePosition(QTextCursor.MoveOperation.End)
        insert_pos = cursor.position()
        cursor.insertText(text)
        self.data_buffer.clear()
        self.serial_display.setUpdatesEnabled(True)

        if self.highlight_config: 
            doc       = self.serial_display.document()
            start_pos = insert_pos
            end_pos   = insert_pos + len(text)
            block     = doc.findBlock(start_pos)

            if not block.isValid(): 
                block = doc.begin()

            while block.isValid() and block.position() &lt; end_pos:
                block_text  = block.text()
                block_start = block.position()

                for keyword, color in self.highlight_config.items():
                    if not keyword: continue 

                    highlight_fmt = QTextCharFormat()
                    highlight_fmt.setBackground(color) 
                    luminance = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255
                    text_color = QColor(&#34;#000000&#34;) if luminance &gt; 0.5 else QColor(&#34;#FFFFFF&#34;)
                    highlight_fmt.setForeground(text_color)
                    highlight_fmt.setFontWeight(QFont.Weight.Bold)

                    idx = block_text.find(keyword)
                    while idx != -1:
                        abs_pos = block_start + idx
                        if abs_pos &gt;= start_pos and abs_pos + len(keyword) &lt;= end_pos:
                            highlight_cursor = QTextCursor(doc)
                            highlight_cursor.setPosition(abs_pos)
                            highlight_cursor.setPosition(abs_pos + len(keyword), QTextCursor.MoveMode.KeepAnchor)
                            highlight_cursor.mergeCharFormat(highlight_fmt)
                        idx = block_text.find(keyword, idx + len(keyword))
                block = block.next()

        # æ›´æ–°æŸ¥æ‰¾è®¡æ•°
        if self.find_dialog.isVisible():
            self.update_find_count()
        
        if self.auto_scroll.isChecked():
            scrollbar.setValue(current_scroll)
        else:
            scrollbar.setValue(scrollbar.maximum())

    if hasattr(self, &#39;pending_table_rows&#39;) and len(self.pending_table_rows) &gt;= 5:
        for data_values in self.pending_table_rows:
            row_position = self.data_table.rowCount()
            self.data_table.insertRow(row_position)
            for col, value in enumerate(data_values):
                self.data_table.setItem(row_position, col, QTableWidgetItem(str(value)))
            if self.data_table.rowCount() &gt; 100:
                self.data_table.removeRow(0)
        self.data_table.scrollToBottom()
        self.pending_table_rows.clear()</code></pre>
</details>
<div class="desc"><p>æ›´æ–°æ˜¾ç¤ºåŒºåŸŸ</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_display2"><code class="name flex">
<span>def <span class="ident">update_display2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_display2(self):
    &#34;&#34;&#34;æ›´æ–°æ˜¾ç¤ºåŒºåŸŸ2&#34;&#34;&#34;
    if self.data_buffer2:
        cursor         = self.serial_display2.textCursor()
        scrollbar      = self.serial_display2.verticalScrollBar()
        current_scroll = scrollbar.value()
        text           = &#39;&#39;.join(self.data_buffer2)
        
        # å¦‚æœé€‰ä¸­äº†æ—¶é—´æˆ³é€‰é¡¹ï¼Œä¸ºæ¯è¡Œæ·»åŠ æ—¶é—´æˆ³
        if self.timestamp2.isChecked():
            lines     = text.splitlines(True)
            timestamp = QDateTime.currentDateTime().toString(&#39;[yyyy-MM-dd hh:mm:ss.zzz] &#39;)
            text      = &#39;&#39;.join(timestamp + line for line in lines)
        
        self.serial_display2.setUpdatesEnabled(False)
        cursor.movePosition(QTextCursor.MoveOperation.End)
        insert_pos = cursor.position()
        cursor.insertText(text)
        self.data_buffer2.clear()
        self.serial_display2.setUpdatesEnabled(True)

        # å¤„ç†é«˜äº®
        if self.highlight_config:
            doc       = self.serial_display2.document()
            start_pos = insert_pos
            end_pos   = insert_pos + len(text)
            block     = doc.findBlock(start_pos)

            if not block.isValid():
                block = doc.begin()

            while block.isValid() and block.position() &lt; end_pos:
                block_text  = block.text()
                block_start = block.position()
                for keyword, color in self.highlight_config.items():
                    if not keyword:
                        continue
                    highlight_fmt = QTextCharFormat()
                    highlight_fmt.setBackground(color)
                    luminance = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255
                    text_color = QColor(&#34;#000000&#34;) if luminance &gt; 0.5 else QColor(&#34;#FFFFFF&#34;)
                    highlight_fmt.setForeground(text_color)
                    highlight_fmt.setFontWeight(QFont.Weight.Bold)
                    
                    idx = block_text.find(keyword)
                    while idx != -1:
                        abs_pos = block_start + idx
                        if abs_pos &gt;= start_pos and abs_pos + len(keyword) &lt;= end_pos:
                            highlight_cursor = QTextCursor(doc)
                            highlight_cursor.setPosition(abs_pos)
                            highlight_cursor.setPosition(abs_pos + len(keyword), QTextCursor.MoveMode.KeepAnchor)
                            highlight_cursor.setCharFormat(highlight_fmt)
                        idx = block_text.find(keyword, idx + len(keyword))
                block = block.next()

        # æ›´æ–°æŸ¥æ‰¾è®¡æ•°
        if self.find_dialog2.isVisible():
            self.update_find_count2()
        
        if self.auto_scroll2.isChecked():
            scrollbar.setValue(current_scroll)
        else:
            scrollbar.setValue(scrollbar.maximum())</code></pre>
</details>
<div class="desc"><p>æ›´æ–°æ˜¾ç¤ºåŒºåŸŸ2</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_find_count"><code class="name flex">
<span>def <span class="ident">update_find_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_find_count(self):
    &#34;&#34;&#34;å¢é‡æ›´æ–°æŸ¥æ‰¾ç»“æœè®¡æ•°&#34;&#34;&#34;
    text = self.find_input.text()
    content = self.serial_display.toPlainText()
    # å¢é‡ç¼“å­˜ï¼šåªå¯¹æ–°å¢å†…å®¹æŸ¥æ‰¾
    if not hasattr(self, &#39;_find_count_cache&#39;):
        self._find_count_cache = {&#39;text&#39;: &#39;&#39;, &#39;content_len&#39;: 0, &#39;count&#39;: 0}
    cache = self._find_count_cache

    if not text:
        self.count_label.setText(&#34;0/0&#34;)
        cache[&#39;text&#39;]        = &#39;&#39;
        cache[&#39;content_len&#39;] = 0
        cache[&#39;count&#39;]       = 0
        return

    if text != cache[&#39;text&#39;]:
        # å…³é”®å­—å˜äº†ï¼Œé‡æ–°å…¨é‡æŸ¥æ‰¾
        count = content.count(text)
        cache[&#39;text&#39;]        = text
        cache[&#39;content_len&#39;] = len(content)
        cache[&#39;count&#39;]       = count
    else:
        # å…³é”®å­—æ²¡å˜ï¼ŒåªæŸ¥æ‰¾æ–°å¢éƒ¨åˆ†
        old_len = cache[&#39;content_len&#39;]
        if len(content) &gt; old_len:
            new_part              = content[old_len:]
            count_new             = new_part.count(text)
            cache[&#39;count&#39;]       += count_new
            cache[&#39;content_len&#39;]  = len(content)
        # å¦‚æœå†…å®¹è¢«æ¸…ç©ºæˆ–å‡å°‘ï¼Œé‡æ–°å…¨é‡æŸ¥æ‰¾
        elif len(content) &lt; old_len:
            count                = content.count(text)
            cache[&#39;count&#39;]       = count
            cache[&#39;content_len&#39;] = len(content)

    count   = cache[&#39;count&#39;]
    current = 0
    # è·å–å½“å‰é€‰ä¸­çš„ä½ç½®
    cursor = self.serial_display.textCursor()
    if cursor.hasSelection():
        sel_text = cursor.selectedText()
        if sel_text == text:
            pos     = cursor.position() - len(text)
            current = content[:pos].count(text) + 1
    self.count_label.setText(f&#34;{current}/{count}&#34;)</code></pre>
</details>
<div class="desc"><p>å¢é‡æ›´æ–°æŸ¥æ‰¾ç»“æœè®¡æ•°</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_find_count2"><code class="name flex">
<span>def <span class="ident">update_find_count2</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_find_count2(self):
    &#34;&#34;&#34;å¢é‡æ›´æ–°æŸ¥æ‰¾ç»“æœè®¡æ•°&#34;&#34;&#34;
    text    = self.find_input2.text()
    content = self.serial_display2.toPlainText()
    
    # å¢é‡ç¼“å­˜ï¼šåªå¯¹æ–°å¢å†…å®¹æŸ¥æ‰¾
    if not hasattr(self, &#39;_find_count_cache2&#39;):
        self._find_count_cache2 = {&#39;text&#39;: &#39;&#39;, &#39;content_len&#39;: 0, &#39;count&#39;: 0}
    cache = self._find_count_cache2

    if not text:
        self.count_label2.setText(&#34;0/0&#34;)
        cache[&#39;text&#39;]        = &#39;&#39;
        cache[&#39;content_len&#39;] = 0
        cache[&#39;count&#39;]       = 0
        return

    if text != cache[&#39;text&#39;]:
        count = content.count(text)
        cache[&#39;text&#39;]        = text
        cache[&#39;content_len&#39;] = len(content)
        cache[&#39;count&#39;]       = count
    else:
        old_len = cache[&#39;content_len&#39;]
        if len(content) &gt; old_len:
            new_part  = content[old_len:]
            count_new = new_part.count(text)
            cache[&#39;count&#39;]       += count_new
            cache[&#39;content_len&#39;]  = len(content)
        elif len(content) &lt; old_len:
            count                = content.count(text)
            cache[&#39;count&#39;]       = count
            cache[&#39;content_len&#39;] = len(content)

    count = cache[&#39;count&#39;]
    
    # è·å–å½“å‰é€‰ä¸­çš„ä½ç½®
    current = 0
    cursor  = self.serial_display2.textCursor()
    if cursor.hasSelection():
        sel_text = cursor.selectedText()
        if sel_text == text:
            pos     = cursor.position() - len(text)
            current = content[:pos].count(text) + 1
    
    self.count_label2.setText(f&#34;{current}/{count}&#34;)</code></pre>
</details>
<div class="desc"><p>å¢é‡æ›´æ–°æŸ¥æ‰¾ç»“æœè®¡æ•°</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_max_lines"><code class="name flex">
<span>def <span class="ident">update_max_lines</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_max_lines(self, value):
    &#34;&#34;&#34;æ›´æ–°æ˜¾ç¤ºåŒºåŸŸæœ€å¤§è¡Œæ•°&#34;&#34;&#34;
    self.serial_display.document().setMaximumBlockCount(value)</code></pre>
</details>
<div class="desc"><p>æ›´æ–°æ˜¾ç¤ºåŒºåŸŸæœ€å¤§è¡Œæ•°</p></div>
</dd>
<dt id="UWBDash.MainWindow.update_max_lines2"><code class="name flex">
<span>def <span class="ident">update_max_lines2</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_max_lines2(self, value):
    self.serial_display2.document().setMaximumBlockCount(value)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.MainWindow.wheelEvent"><code class="name flex">
<span>def <span class="ident">wheelEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wheelEvent(self, event):
    current_idx = self.stacked_widget.currentIndex()
    # æ£€æµ‹æ»šè½®æ–¹å‘ï¼ˆæ­£å€¼è¡¨ç¤ºå‘ä¸Šæ»šåŠ¨ï¼‰
    delta = event.angleDelta().y()
    
    if current_idx == 0:  # COM 1 é¡µé¢
        if delta &gt; 0:  # å‘ä¸Šæ»šåŠ¨
            self.auto_scroll.setChecked(True)  
        elif delta &lt; 0 and not self.auto_scroll.isChecked():  # å‘ä¸‹æ»šåŠ¨ä¸”è‡ªåŠ¨æ»šåŠ¨æœªå¯ç”¨
            # å¯é€‰ï¼šåœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å‘ä¸‹æ»šåŠ¨é€»è¾‘
            pass
    elif current_idx == 1:  # COM 2 é¡µé¢
        if delta &gt; 0:  # å‘ä¸Šæ»šåŠ¨
            self.auto_scroll2.setChecked(True)  
        elif delta &lt; 0 and not self.auto_scroll2.isChecked():  # å‘ä¸‹æ»šåŠ¨ä¸”è‡ªåŠ¨æ»šåŠ¨æœªå¯ç”¨
            # å¯é€‰ï¼šåœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å‘ä¸‹æ»šåŠ¨é€»è¾‘
            pass
            
    # è°ƒç”¨çˆ¶ç±»æ–¹æ³•ä»¥ä¿æŒæ­£å¸¸çš„æ»šåŠ¨è¡Œä¸º
    super().wheelEvent(event)</code></pre>
</details>
<div class="desc"><p>wheelEvent(self, a0: Optional[QWheelEvent])</p></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.Particle"><code class="flex name class">
<span>class <span class="ident">Particle</span></span>
<span>(</span><span>bounds_rect)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Particle:
    def __init__(self, bounds_rect):
        self.bounds = bounds_rect
        self.reset()

    def reset(self):
        self.pos = QPointF(random.uniform(0, self.bounds.width()),
                         random.uniform(0, self.bounds.height()))
        # ç²’å­é€Ÿåº¦
        self.vel = QPointF(random.uniform(-0.5, 0.5), random.uniform(-0.8, -1.8))

        self.color = QColor(random.randint(100, 200), 
                          random.randint(100, 200), 
                          random.randint(200, 255), 
                          random.randint(30, 120))
        # ç²’å­å°ºå¯¸
        self.size = random.uniform(3.0, 6.0)

    def update(self):
        self.pos += self.vel
        if not self.bounds.contains(self.pos):
            self.pos = QPointF(random.uniform(0, self.bounds.width()), self.bounds.height() -1)
            self.vel = QPointF(random.uniform(-0.5, 0.5), random.uniform(-0.8, -1.8))</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.Particle.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    self.pos = QPointF(random.uniform(0, self.bounds.width()),
                     random.uniform(0, self.bounds.height()))
    # ç²’å­é€Ÿåº¦
    self.vel = QPointF(random.uniform(-0.5, 0.5), random.uniform(-0.8, -1.8))

    self.color = QColor(random.randint(100, 200), 
                      random.randint(100, 200), 
                      random.randint(200, 255), 
                      random.randint(30, 120))
    # ç²’å­å°ºå¯¸
    self.size = random.uniform(3.0, 6.0)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.Particle.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    self.pos += self.vel
    if not self.bounds.contains(self.pos):
        self.pos = QPointF(random.uniform(0, self.bounds.width()), self.bounds.height() -1)
        self.vel = QPointF(random.uniform(-0.5, 0.5), random.uniform(-0.8, -1.8))</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.ParticleEffectWidget"><code class="flex name class">
<span>class <span class="ident">ParticleEffectWidget</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParticleEffectWidget(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)
        self.setStyleSheet(&#34;background: transparent;&#34;)
        self.setAttribute(Qt.WidgetAttribute.WA_TransparentForMouseEvents, True)
        self.particles = []
        self.num_particles = 100
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_particles_and_repaint)
        self._particles_initialized = False

    def _initialize_particles(self):
        if self.width() &gt; 0 and self.height() &gt; 0:
            bounds = QRectF(0, 0, self.width(), self.height())
            self.particles = [Particle(bounds) for _ in range(self.num_particles)]
            self._particles_initialized = True

    def start_animation(self):
        if not self.isVisible():
            return
        if not self._particles_initialized and self.width() &gt; 0 and self.height() &gt; 0:
            self._initialize_particles()
        if self._particles_initialized and not self.timer.isActive():
            self.timer.start(30)

    def stop_animation(self):
        self.timer.stop()

    def update_particles_and_repaint(self):
        if not self.isVisible() or not self._particles_initialized:
            self.stop_animation()
            return
        for p in self.particles:
            p.update()
        self.update()

    def paintEvent(self, event):
        if not self._particles_initialized:
            return
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        for p in self.particles:
            painter.setBrush(p.color)
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawEllipse(p.pos, p.size, p.size)
        super().paintEvent(event)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        if self.width() &gt; 0 and self.height() &gt; 0:
            new_bounds = QRectF(0, 0, self.width(), self.height())
            if not self._particles_initialized:
                self._initialize_particles()
            else:
                for p in self.particles:
                    p.bounds = new_bounds
                    if not new_bounds.contains(p.pos):
                        p.reset()
            if self.isVisible() and not self.timer.isActive():
                self.start_animation()
        self.update()

    def showEvent(self, event):
        super().showEvent(event)
        self.start_animation()

    def hideEvent(self, event):
        super().hideEvent(event)
        self.stop_animation()</code></pre>
</details>
<div class="desc"><p>QWidget(parent: Optional[QWidget] = None, flags: Qt.WindowType = Qt.WindowFlags())</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtWidgets.QWidget</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.QtGui.QPaintDevice</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.ParticleEffectWidget.hideEvent"><code class="name flex">
<span>def <span class="ident">hideEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hideEvent(self, event):
    super().hideEvent(event)
    self.stop_animation()</code></pre>
</details>
<div class="desc"><p>hideEvent(self, a0: Optional[QHideEvent])</p></div>
</dd>
<dt id="UWBDash.ParticleEffectWidget.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event):
    if not self._particles_initialized:
        return
    painter = QPainter(self)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
    for p in self.particles:
        painter.setBrush(p.color)
        painter.setPen(Qt.PenStyle.NoPen)
        painter.drawEllipse(p.pos, p.size, p.size)
    super().paintEvent(event)</code></pre>
</details>
<div class="desc"><p>paintEvent(self, a0: Optional[QPaintEvent])</p></div>
</dd>
<dt id="UWBDash.ParticleEffectWidget.resizeEvent"><code class="name flex">
<span>def <span class="ident">resizeEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resizeEvent(self, event):
    super().resizeEvent(event)
    if self.width() &gt; 0 and self.height() &gt; 0:
        new_bounds = QRectF(0, 0, self.width(), self.height())
        if not self._particles_initialized:
            self._initialize_particles()
        else:
            for p in self.particles:
                p.bounds = new_bounds
                if not new_bounds.contains(p.pos):
                    p.reset()
        if self.isVisible() and not self.timer.isActive():
            self.start_animation()
    self.update()</code></pre>
</details>
<div class="desc"><p>resizeEvent(self, a0: Optional[QResizeEvent])</p></div>
</dd>
<dt id="UWBDash.ParticleEffectWidget.showEvent"><code class="name flex">
<span>def <span class="ident">showEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def showEvent(self, event):
    super().showEvent(event)
    self.start_animation()</code></pre>
</details>
<div class="desc"><p>showEvent(self, a0: Optional[QShowEvent])</p></div>
</dd>
<dt id="UWBDash.ParticleEffectWidget.start_animation"><code class="name flex">
<span>def <span class="ident">start_animation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_animation(self):
    if not self.isVisible():
        return
    if not self._particles_initialized and self.width() &gt; 0 and self.height() &gt; 0:
        self._initialize_particles()
    if self._particles_initialized and not self.timer.isActive():
        self.timer.start(30)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.ParticleEffectWidget.stop_animation"><code class="name flex">
<span>def <span class="ident">stop_animation</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_animation(self):
    self.timer.stop()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.ParticleEffectWidget.update_particles_and_repaint"><code class="name flex">
<span>def <span class="ident">update_particles_and_repaint</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_particles_and_repaint(self):
    if not self.isVisible() or not self._particles_initialized:
        self.stop_animation()
        return
    for p in self.particles:
        p.update()
    self.update()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.PositionView"><code class="flex name class">
<span>class <span class="ident">PositionView</span></span>
<span>(</span><span>parent=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PositionView(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_position = None
        self.last_position    = None
        self.scale            = 2
        self.origin_offset_y  = -200
        
        # åˆ›å»ºé™æ€å†…å®¹ç¼“å­˜
        self.static_content   = None
        
    def draw_static_content(self, painter, center_x, center_y):
        # çº¢è‰²æ„Ÿåº”åŒºï¼ˆå¯¹ç§°åˆ†å¸ƒåœ¨åŸç‚¹ä¸Šä¸‹ï¼‰
        red_gradient = QLinearGradient(center_x, center_y, center_x, center_y + 50)
        red_gradient.setColorAt(0, QColor(255, 0, 0, 70))  # å¢åŠ çº¢è‰²é€æ˜åº¦
        red_gradient.setColorAt(1, QColor(255, 0, 0, 30))
        painter.setBrush(red_gradient)
        painter.setPen(Qt.PenStyle.NoPen)
        painter.drawRect(int(center_x - 100), int(center_y), 200, 100)
        
        # è“è‰²åŒºåŸŸï¼ˆä¸çº¢è‰²åŒºåŸŸç­‰å®½ï¼‰
        blue_gradient = QLinearGradient(center_x, center_y + 50, center_x, center_y + 300)
        blue_gradient.setColorAt(0, QColor(0, 140, 255, 60))  # å¢åŠ è“è‰²é€æ˜åº¦å’Œé¥±å’Œåº¦
        blue_gradient.setColorAt(1, QColor(0, 140, 255, 30))
        painter.setBrush(blue_gradient)
        painter.drawRect(int(center_x - 100), int(center_y + 100), 200, 250)
        
        # ç»˜åˆ¶é—¸æœºï¼ˆå·¦ä¾§ï¼‰
        painter.setPen(QPen(QColor(&#34;#333333&#34;), 2))
        painter.setBrush(QColor(&#34;#444444&#34;))
        painter.drawRect(int(center_x - 100), int(center_y - 40), 20, 80)  # ä¿®æ”¹ä¸º-100
        # é—¸æœºè£…é¥°
        painter.setPen(QPen(QColor(&#34;#666666&#34;), 1))
        painter.drawLine(int(center_x - 95), int(center_y - 30), int(center_x - 85), int(center_y - 30))  # å¯¹åº”è°ƒæ•´è£…é¥°çº¿
        painter.drawLine(int(center_x - 95), int(center_y), int(center_x - 85), int(center_y))
        painter.drawLine(int(center_x - 95), int(center_y + 30), int(center_x - 85), int(center_y + 30))
        
        # ç»˜åˆ¶é—¸æœºï¼ˆå³ä¾§ï¼‰
        painter.setPen(QPen(QColor(&#34;#333333&#34;), 2))
        painter.setBrush(QColor(&#34;#444444&#34;))
        painter.drawRect(int(center_x + 80), int(center_y - 40), 20, 80)  # ä¿®æ”¹ä¸º+80ï¼Œè€ƒè™‘é—¸æœºå®½åº¦20
        # é—¸æœºè£…é¥°
        painter.setPen(QPen(QColor(&#34;#666666&#34;), 1))
        painter.drawLine(int(center_x + 85), int(center_y - 30), int(center_x + 95), int(center_y - 30))  # å¯¹åº”è°ƒæ•´è£…é¥°çº¿
        painter.drawLine(int(center_x + 85), int(center_y), int(center_x + 95), int(center_y))
        painter.drawLine(int(center_x + 85), int(center_y + 30), int(center_x + 95), int(center_y + 30))
        
        # ç»˜åˆ¶åæ ‡è½´
        painter.setPen(QPen(QColor(&#34;#666666&#34;), 1))
        painter.drawLine(0, int(center_y), self.width(), int(center_y))
        painter.drawLine(int(center_x), 0, int(center_x), self.height())
        
        # ç»˜åˆ¶åŸç‚¹ï¼ˆçº¢è‰²ï¼‰
        painter.setPen(QPen(QColor(&#34;#FF0000&#34;), 2))
        painter.setBrush(QColor(&#34;#FF0000&#34;))
        painter.drawEllipse(int(center_x) - 2, int(center_y) - 2, 4, 4)
        
    def create_static_content(self):
        &#34;&#34;&#34;åˆ›å»ºé™æ€å†…å®¹ç¼“å­˜&#34;&#34;&#34;
        self.static_content = QPixmap(self.size())
        self.static_content.fill(Qt.GlobalColor.transparent)
        
        painter = QPainter(self.static_content)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # è·å–çª—å£ä¸­å¿ƒ
        center_x = self.width() / 2
        center_y = self.height() / 2 + self.origin_offset_y
        
        # ç»˜åˆ¶é™æ€å†…å®¹
        self.draw_static_content(painter, center_x, center_y)
        painter.end()
        
    def update_position(self, x, y):
        &#34;&#34;&#34;æ›´æ–°ä½ç½®å¹¶è§¦å‘é‡ç»˜&#34;&#34;&#34;
        self.last_position = self.current_position
        self.current_position = (x, y)
        self.update()
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # å¦‚æœé™æ€å†…å®¹ä¸å­˜åœ¨æˆ–çª—å£å¤§å°æ”¹å˜ï¼Œé‡æ–°åˆ›å»º
        if self.static_content is None or \
           self.static_content.size() != self.size():
            self.create_static_content()
        
        # ç»˜åˆ¶é™æ€å†…å®¹
        painter.drawPixmap(0, 0, self.static_content)
            
        # å¦‚æœæ²¡æœ‰ä½ç½®æ•°æ®ï¼Œåˆ°æ­¤ç»“æŸ
        if not self.current_position:
            return
            
        # è·å–çª—å£ä¸­å¿ƒï¼ˆç”¨äºåŠ¨æ€å†…å®¹ï¼‰
        center_x = self.width() / 2
        center_y = self.height() / 2 + self.origin_offset_y
        
        # ç»˜åˆ¶åŠ¨æ€å†…å®¹ï¼ˆä½ç½®ç‚¹å’Œè½¨è¿¹ï¼‰
        x, y = self.current_position
        screen_x = center_x + x * self.scale
        screen_y = center_y + y * self.scale

        # ç»˜åˆ¶åæ ‡æ–‡æœ¬èƒŒæ™¯
        coord_text = f&#34;X: {int(x)}, Y: {int(y)}&#34;
        bg_rect = painter.fontMetrics().boundingRect(coord_text)
        bg_rect.adjust(-15, -5, 15, 5)  # æ‰©å¤§èƒŒæ™¯åŒºåŸŸ
        bg_rect.moveTopLeft(QPoint(10, 5))
        painter.setPen(Qt.PenStyle.NoPen)
        painter.setBrush(QColor(0, 0, 0, 120))  # åŠé€æ˜é»‘è‰²èƒŒæ™¯
        painter.drawRoundedRect(bg_rect, 5, 5)  # åœ†è§’çŸ©å½¢èƒŒæ™¯
        
        # ç»˜åˆ¶åæ ‡æ–‡æœ¬
        painter.setPen(QPen(QColor(&#34;#ffffff&#34;), 2))  # ç™½è‰²æ–‡æœ¬
        painter.setFont(QFont(&#34;Segoe UI&#34;, 12, QFont.Weight.Bold))  # åŠ ç²—å­—ä½“
        painter.drawText(15, 23, coord_text)
        
        if self.last_position:
            last_x, last_y = self.last_position
            last_screen_x = center_x + last_x * self.scale
            last_screen_y = center_y + last_y * self.scale
            
            # ä½¿ç”¨æ¸å˜è‰²ç»˜åˆ¶è½¨è¿¹
            gradient = QLinearGradient(last_screen_x, last_screen_y, screen_x, screen_y)
            gradient.setColorAt(0, QColor(74, 144, 226, 25))  # èµ·ç‚¹é¢œè‰²ï¼ˆè¾ƒæ·¡ï¼‰
            gradient.setColorAt(1, QColor(74, 144, 226, 200))  # ç»ˆç‚¹é¢œè‰²ï¼ˆè¾ƒæ·±ï¼‰
            
            pen = QPen()
            pen.setBrush(gradient)
            pen.setWidth(5)  # å¢åŠ çº¿æ¡å®½åº¦
            painter.setPen(pen)
            painter.drawLine(int(last_screen_x), int(last_screen_y), 
                           int(screen_x), int(screen_y))
        
        # ç»˜åˆ¶å½“å‰ä½ç½®ç‚¹
        painter.setPen(QPen(QColor(&#34;#4a90e2&#34;), 2))
        painter.setBrush(QColor(74, 144, 226, 255))
        painter.drawEllipse(int(screen_x) - 6, int(screen_y) - 6, 12, 12)  # å¢å¤§ç‚¹çš„å¤§å°</code></pre>
</details>
<div class="desc"><p>QWidget(parent: Optional[QWidget] = None, flags: Qt.WindowType = Qt.WindowFlags())</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtWidgets.QWidget</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.QtGui.QPaintDevice</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.PositionView.create_static_content"><code class="name flex">
<span>def <span class="ident">create_static_content</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_static_content(self):
    &#34;&#34;&#34;åˆ›å»ºé™æ€å†…å®¹ç¼“å­˜&#34;&#34;&#34;
    self.static_content = QPixmap(self.size())
    self.static_content.fill(Qt.GlobalColor.transparent)
    
    painter = QPainter(self.static_content)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
    
    # è·å–çª—å£ä¸­å¿ƒ
    center_x = self.width() / 2
    center_y = self.height() / 2 + self.origin_offset_y
    
    # ç»˜åˆ¶é™æ€å†…å®¹
    self.draw_static_content(painter, center_x, center_y)
    painter.end()</code></pre>
</details>
<div class="desc"><p>åˆ›å»ºé™æ€å†…å®¹ç¼“å­˜</p></div>
</dd>
<dt id="UWBDash.PositionView.draw_static_content"><code class="name flex">
<span>def <span class="ident">draw_static_content</span></span>(<span>self, painter, center_x, center_y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_static_content(self, painter, center_x, center_y):
    # çº¢è‰²æ„Ÿåº”åŒºï¼ˆå¯¹ç§°åˆ†å¸ƒåœ¨åŸç‚¹ä¸Šä¸‹ï¼‰
    red_gradient = QLinearGradient(center_x, center_y, center_x, center_y + 50)
    red_gradient.setColorAt(0, QColor(255, 0, 0, 70))  # å¢åŠ çº¢è‰²é€æ˜åº¦
    red_gradient.setColorAt(1, QColor(255, 0, 0, 30))
    painter.setBrush(red_gradient)
    painter.setPen(Qt.PenStyle.NoPen)
    painter.drawRect(int(center_x - 100), int(center_y), 200, 100)
    
    # è“è‰²åŒºåŸŸï¼ˆä¸çº¢è‰²åŒºåŸŸç­‰å®½ï¼‰
    blue_gradient = QLinearGradient(center_x, center_y + 50, center_x, center_y + 300)
    blue_gradient.setColorAt(0, QColor(0, 140, 255, 60))  # å¢åŠ è“è‰²é€æ˜åº¦å’Œé¥±å’Œåº¦
    blue_gradient.setColorAt(1, QColor(0, 140, 255, 30))
    painter.setBrush(blue_gradient)
    painter.drawRect(int(center_x - 100), int(center_y + 100), 200, 250)
    
    # ç»˜åˆ¶é—¸æœºï¼ˆå·¦ä¾§ï¼‰
    painter.setPen(QPen(QColor(&#34;#333333&#34;), 2))
    painter.setBrush(QColor(&#34;#444444&#34;))
    painter.drawRect(int(center_x - 100), int(center_y - 40), 20, 80)  # ä¿®æ”¹ä¸º-100
    # é—¸æœºè£…é¥°
    painter.setPen(QPen(QColor(&#34;#666666&#34;), 1))
    painter.drawLine(int(center_x - 95), int(center_y - 30), int(center_x - 85), int(center_y - 30))  # å¯¹åº”è°ƒæ•´è£…é¥°çº¿
    painter.drawLine(int(center_x - 95), int(center_y), int(center_x - 85), int(center_y))
    painter.drawLine(int(center_x - 95), int(center_y + 30), int(center_x - 85), int(center_y + 30))
    
    # ç»˜åˆ¶é—¸æœºï¼ˆå³ä¾§ï¼‰
    painter.setPen(QPen(QColor(&#34;#333333&#34;), 2))
    painter.setBrush(QColor(&#34;#444444&#34;))
    painter.drawRect(int(center_x + 80), int(center_y - 40), 20, 80)  # ä¿®æ”¹ä¸º+80ï¼Œè€ƒè™‘é—¸æœºå®½åº¦20
    # é—¸æœºè£…é¥°
    painter.setPen(QPen(QColor(&#34;#666666&#34;), 1))
    painter.drawLine(int(center_x + 85), int(center_y - 30), int(center_x + 95), int(center_y - 30))  # å¯¹åº”è°ƒæ•´è£…é¥°çº¿
    painter.drawLine(int(center_x + 85), int(center_y), int(center_x + 95), int(center_y))
    painter.drawLine(int(center_x + 85), int(center_y + 30), int(center_x + 95), int(center_y + 30))
    
    # ç»˜åˆ¶åæ ‡è½´
    painter.setPen(QPen(QColor(&#34;#666666&#34;), 1))
    painter.drawLine(0, int(center_y), self.width(), int(center_y))
    painter.drawLine(int(center_x), 0, int(center_x), self.height())
    
    # ç»˜åˆ¶åŸç‚¹ï¼ˆçº¢è‰²ï¼‰
    painter.setPen(QPen(QColor(&#34;#FF0000&#34;), 2))
    painter.setBrush(QColor(&#34;#FF0000&#34;))
    painter.drawEllipse(int(center_x) - 2, int(center_y) - 2, 4, 4)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="UWBDash.PositionView.paintEvent"><code class="name flex">
<span>def <span class="ident">paintEvent</span></span>(<span>self, event)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paintEvent(self, event):
    painter = QPainter(self)
    painter.setRenderHint(QPainter.RenderHint.Antialiasing)
    
    # å¦‚æœé™æ€å†…å®¹ä¸å­˜åœ¨æˆ–çª—å£å¤§å°æ”¹å˜ï¼Œé‡æ–°åˆ›å»º
    if self.static_content is None or \
       self.static_content.size() != self.size():
        self.create_static_content()
    
    # ç»˜åˆ¶é™æ€å†…å®¹
    painter.drawPixmap(0, 0, self.static_content)
        
    # å¦‚æœæ²¡æœ‰ä½ç½®æ•°æ®ï¼Œåˆ°æ­¤ç»“æŸ
    if not self.current_position:
        return
        
    # è·å–çª—å£ä¸­å¿ƒï¼ˆç”¨äºåŠ¨æ€å†…å®¹ï¼‰
    center_x = self.width() / 2
    center_y = self.height() / 2 + self.origin_offset_y
    
    # ç»˜åˆ¶åŠ¨æ€å†…å®¹ï¼ˆä½ç½®ç‚¹å’Œè½¨è¿¹ï¼‰
    x, y = self.current_position
    screen_x = center_x + x * self.scale
    screen_y = center_y + y * self.scale

    # ç»˜åˆ¶åæ ‡æ–‡æœ¬èƒŒæ™¯
    coord_text = f&#34;X: {int(x)}, Y: {int(y)}&#34;
    bg_rect = painter.fontMetrics().boundingRect(coord_text)
    bg_rect.adjust(-15, -5, 15, 5)  # æ‰©å¤§èƒŒæ™¯åŒºåŸŸ
    bg_rect.moveTopLeft(QPoint(10, 5))
    painter.setPen(Qt.PenStyle.NoPen)
    painter.setBrush(QColor(0, 0, 0, 120))  # åŠé€æ˜é»‘è‰²èƒŒæ™¯
    painter.drawRoundedRect(bg_rect, 5, 5)  # åœ†è§’çŸ©å½¢èƒŒæ™¯
    
    # ç»˜åˆ¶åæ ‡æ–‡æœ¬
    painter.setPen(QPen(QColor(&#34;#ffffff&#34;), 2))  # ç™½è‰²æ–‡æœ¬
    painter.setFont(QFont(&#34;Segoe UI&#34;, 12, QFont.Weight.Bold))  # åŠ ç²—å­—ä½“
    painter.drawText(15, 23, coord_text)
    
    if self.last_position:
        last_x, last_y = self.last_position
        last_screen_x = center_x + last_x * self.scale
        last_screen_y = center_y + last_y * self.scale
        
        # ä½¿ç”¨æ¸å˜è‰²ç»˜åˆ¶è½¨è¿¹
        gradient = QLinearGradient(last_screen_x, last_screen_y, screen_x, screen_y)
        gradient.setColorAt(0, QColor(74, 144, 226, 25))  # èµ·ç‚¹é¢œè‰²ï¼ˆè¾ƒæ·¡ï¼‰
        gradient.setColorAt(1, QColor(74, 144, 226, 200))  # ç»ˆç‚¹é¢œè‰²ï¼ˆè¾ƒæ·±ï¼‰
        
        pen = QPen()
        pen.setBrush(gradient)
        pen.setWidth(5)  # å¢åŠ çº¿æ¡å®½åº¦
        painter.setPen(pen)
        painter.drawLine(int(last_screen_x), int(last_screen_y), 
                       int(screen_x), int(screen_y))
    
    # ç»˜åˆ¶å½“å‰ä½ç½®ç‚¹
    painter.setPen(QPen(QColor(&#34;#4a90e2&#34;), 2))
    painter.setBrush(QColor(74, 144, 226, 255))
    painter.drawEllipse(int(screen_x) - 6, int(screen_y) - 6, 12, 12)  # å¢å¤§ç‚¹çš„å¤§å°</code></pre>
</details>
<div class="desc"><p>paintEvent(self, a0: Optional[QPaintEvent])</p></div>
</dd>
<dt id="UWBDash.PositionView.update_position"><code class="name flex">
<span>def <span class="ident">update_position</span></span>(<span>self, x, y)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_position(self, x, y):
    &#34;&#34;&#34;æ›´æ–°ä½ç½®å¹¶è§¦å‘é‡ç»˜&#34;&#34;&#34;
    self.last_position = self.current_position
    self.current_position = (x, y)
    self.update()</code></pre>
</details>
<div class="desc"><p>æ›´æ–°ä½ç½®å¹¶è§¦å‘é‡ç»˜</p></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.SerialReadThread"><code class="flex name class">
<span>class <span class="ident">SerialReadThread</span></span>
<span>(</span><span>serial_port)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerialReadThread(QThread):
    data_received = pyqtSignal(bytes)
    
    def __init__(self, serial_port):
        super().__init__()
        self.serial_port = serial_port
        self.running     = False
        
    def run(self):
        self.running = True
        buffer       = bytearray()
        while self.running and self.serial_port.is_open:
            try:
                if self.serial_port.in_waiting:
                    # ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©æ•°æ®å®Œæ•´åˆ°è¾¾
                    time.sleep(0.05)
                    data = self.serial_port.read(self.serial_port.in_waiting)
                    if data:
                        buffer.extend(data)
                        # æ£€æŸ¥æ˜¯å¦æœ‰å®Œæ•´çš„è¡Œ
                        while b&#39;\n&#39; in buffer:
                            line_end = buffer.find(b&#39;\n&#39;)
                            # æå–å®Œæ•´çš„è¡Œï¼ˆåŒ…æ‹¬æ¢è¡Œç¬¦ï¼‰
                            line = bytes(buffer[:line_end + 1])
                            buffer = buffer[line_end + 1:]
                            if line.strip():  # å¿½ç•¥ç©ºè¡Œ
                                self.data_received.emit(line)
            except Exception as e:
                print(f&#34;ä¸²å£è¯»å–é”™è¯¯: {str(e)}&#34;)
                break
            time.sleep(0.01)  # é™ä½CPUå ç”¨
            
    def stop(self):
        self.running = False
        self.wait()</code></pre>
</details>
<div class="desc"><p>QThread(parent: Optional[QObject] = None)</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt6.QtCore.QThread</li>
<li>PyQt6.QtCore.QObject</li>
<li>PyQt6.sip.wrapper</li>
<li>PyQt6.sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="UWBDash.SerialReadThread.data_received"><code class="name flex">
<span>def <span class="ident">data_received</span></span>(<span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>pyqtSignal(*types, name: str = &hellip;, revision: int = &hellip;, arguments: Sequence = &hellip;) -&gt; PYQT_SIGNAL</p>
<p>types is normally a sequence of individual types.
Each type is either a
type object or a string that is the name of a C++ type.
Alternatively
each type could itself be a sequence of types each describing a different
overloaded signal.
name is the optional C++ name of the signal.
If it is not specified then
the name of the class attribute that is bound to the signal is used.
revision is the optional revision of the signal that is exported to QML.
If it is not specified then 0 is used.
arguments is the optional sequence of the names of the signal's arguments.</p></div>
</dd>
<dt id="UWBDash.SerialReadThread.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    self.running = True
    buffer       = bytearray()
    while self.running and self.serial_port.is_open:
        try:
            if self.serial_port.in_waiting:
                # ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©æ•°æ®å®Œæ•´åˆ°è¾¾
                time.sleep(0.05)
                data = self.serial_port.read(self.serial_port.in_waiting)
                if data:
                    buffer.extend(data)
                    # æ£€æŸ¥æ˜¯å¦æœ‰å®Œæ•´çš„è¡Œ
                    while b&#39;\n&#39; in buffer:
                        line_end = buffer.find(b&#39;\n&#39;)
                        # æå–å®Œæ•´çš„è¡Œï¼ˆåŒ…æ‹¬æ¢è¡Œç¬¦ï¼‰
                        line = bytes(buffer[:line_end + 1])
                        buffer = buffer[line_end + 1:]
                        if line.strip():  # å¿½ç•¥ç©ºè¡Œ
                            self.data_received.emit(line)
        except Exception as e:
            print(f&#34;ä¸²å£è¯»å–é”™è¯¯: {str(e)}&#34;)
            break
        time.sleep(0.01)  # é™ä½CPUå ç”¨</code></pre>
</details>
<div class="desc"><p>run(self)</p></div>
</dd>
<dt id="UWBDash.SerialReadThread.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self):
    self.running = False
    self.wait()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="UWBDash.ThemeManager"><code class="flex name class">
<span>class <span class="ident">ThemeManager</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThemeManager:
    # ğŸ“ŒğŸ“âŒğŸ”¸
    LIGHT_THEME = {
        &#34;nav_bg&#34;      : &#34;rgba(248, 249, 250,  0.35)&#34;,
        &#34;nav_item&#34;    : &#34;#c29500&#34;,
        &#34;nav_selected&#34;: &#34;rgba(218, 237, 244, 1)&#34;,
        &#34;accent&#34;      : &#34;#4a90e2&#34;,
        &#34;bg&#34;          : &#34;rgba(223, 238, 240, 0.35)&#34;,
        &#34;text&#34;        : &#34;#2d3436&#34;,
        &#34;title_bg&#34;    : &#34;#424e54&#34;
    }

    DARK_THEME = {
        &#34;nav_bg&#34;      : &#34;rgba(45, 52, 54,  0.35)&#34;,
        &#34;nav_item&#34;    : &#34;#c29500&#34;,
        &#34;nav_selected&#34;: &#34;rgba(74, 74, 74,  0.35)&#34;,
        &#34;accent&#34;      : &#34;#6c5ce797&#34;,
        &#34;bg&#34;          : &#34;rgba(53, 59, 64, 0.35)&#34;,
        &#34;text&#34;        : &#34;#f8f9fa&#34;,
        &#34;title_bg&#34;    : &#34;#01285600&#34;
    }</code></pre>
</details>
<div class="desc"></div>
<h3>Class variables</h3>
<dl>
<dt id="UWBDash.ThemeManager.DARK_THEME"><code class="name">var <span class="ident">DARK_THEME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="UWBDash.ThemeManager.LIGHT_THEME"><code class="name">var <span class="ident">LIGHT_THEME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="UWBDash.ChartUpdateThread" href="#UWBDash.ChartUpdateThread">ChartUpdateThread</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.ChartUpdateThread.add_data" href="#UWBDash.ChartUpdateThread.add_data">add_data</a></code></li>
<li><code><a title="UWBDash.ChartUpdateThread.run" href="#UWBDash.ChartUpdateThread.run">run</a></code></li>
<li><code><a title="UWBDash.ChartUpdateThread.stop" href="#UWBDash.ChartUpdateThread.stop">stop</a></code></li>
<li><code><a title="UWBDash.ChartUpdateThread.update_chart" href="#UWBDash.ChartUpdateThread.update_chart">update_chart</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.FindThread" href="#UWBDash.FindThread">FindThread</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.FindThread.result_ready" href="#UWBDash.FindThread.result_ready">result_ready</a></code></li>
<li><code><a title="UWBDash.FindThread.run" href="#UWBDash.FindThread.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.HighlightConfigDialog" href="#UWBDash.HighlightConfigDialog">HighlightConfigDialog</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.HighlightConfigDialog.add_keyword" href="#UWBDash.HighlightConfigDialog.add_keyword">add_keyword</a></code></li>
<li><code><a title="UWBDash.HighlightConfigDialog.edit_keyword" href="#UWBDash.HighlightConfigDialog.edit_keyword">edit_keyword</a></code></li>
<li><code><a title="UWBDash.HighlightConfigDialog.get_config" href="#UWBDash.HighlightConfigDialog.get_config">get_config</a></code></li>
<li><code><a title="UWBDash.HighlightConfigDialog.populate_table" href="#UWBDash.HighlightConfigDialog.populate_table">populate_table</a></code></li>
<li><code><a title="UWBDash.HighlightConfigDialog.remove_keyword" href="#UWBDash.HighlightConfigDialog.remove_keyword">remove_keyword</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.LogWorker" href="#UWBDash.LogWorker">LogWorker</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.LogWorker.add_log_task" href="#UWBDash.LogWorker.add_log_task">add_log_task</a></code></li>
<li><code><a title="UWBDash.LogWorker.run" href="#UWBDash.LogWorker.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.MainWindow" href="#UWBDash.MainWindow">MainWindow</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.MainWindow.apply_theme" href="#UWBDash.MainWindow.apply_theme">apply_theme</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_COM_page" href="#UWBDash.MainWindow.create_COM_page">create_COM_page</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_COM_page2" href="#UWBDash.MainWindow.create_COM_page2">create_COM_page2</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_Chart_page" href="#UWBDash.MainWindow.create_Chart_page">create_Chart_page</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_chart_area" href="#UWBDash.MainWindow.create_chart_area">create_chart_area</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_display_area" href="#UWBDash.MainWindow.create_display_area">create_display_area</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_display_area2" href="#UWBDash.MainWindow.create_display_area2">create_display_area2</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_nav_bar" href="#UWBDash.MainWindow.create_nav_bar">create_nav_bar</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_pages" href="#UWBDash.MainWindow.create_pages">create_pages</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_position_area" href="#UWBDash.MainWindow.create_position_area">create_position_area</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_test_area" href="#UWBDash.MainWindow.create_test_area">create_test_area</a></code></li>
<li><code><a title="UWBDash.MainWindow.create_title_bar" href="#UWBDash.MainWindow.create_title_bar">create_title_bar</a></code></li>
<li><code><a title="UWBDash.MainWindow.eventFilter" href="#UWBDash.MainWindow.eventFilter">eventFilter</a></code></li>
<li><code><a title="UWBDash.MainWindow.find_text" href="#UWBDash.MainWindow.find_text">find_text</a></code></li>
<li><code><a title="UWBDash.MainWindow.find_text2" href="#UWBDash.MainWindow.find_text2">find_text2</a></code></li>
<li><code><a title="UWBDash.MainWindow.handle_serial_2_data" href="#UWBDash.MainWindow.handle_serial_2_data">handle_serial_2_data</a></code></li>
<li><code><a title="UWBDash.MainWindow.handle_serial_data" href="#UWBDash.MainWindow.handle_serial_data">handle_serial_data</a></code></li>
<li><code><a title="UWBDash.MainWindow.init_ui" href="#UWBDash.MainWindow.init_ui">init_ui</a></code></li>
<li><code><a title="UWBDash.MainWindow.load_highlight_config" href="#UWBDash.MainWindow.load_highlight_config">load_highlight_config</a></code></li>
<li><code><a title="UWBDash.MainWindow.mousePressEvent" href="#UWBDash.MainWindow.mousePressEvent">mousePressEvent</a></code></li>
<li><code><a title="UWBDash.MainWindow.on_display_key_press" href="#UWBDash.MainWindow.on_display_key_press">on_display_key_press</a></code></li>
<li><code><a title="UWBDash.MainWindow.on_display_key_press2" href="#UWBDash.MainWindow.on_display_key_press2">on_display_key_press2</a></code></li>
<li><code><a title="UWBDash.MainWindow.on_display_wheel" href="#UWBDash.MainWindow.on_display_wheel">on_display_wheel</a></code></li>
<li><code><a title="UWBDash.MainWindow.on_find_result" href="#UWBDash.MainWindow.on_find_result">on_find_result</a></code></li>
<li><code><a title="UWBDash.MainWindow.on_find_result2" href="#UWBDash.MainWindow.on_find_result2">on_find_result2</a></code></li>
<li><code><a title="UWBDash.MainWindow.open_current_csv_file" href="#UWBDash.MainWindow.open_current_csv_file">open_current_csv_file</a></code></li>
<li><code><a title="UWBDash.MainWindow.open_current_text_log_file" href="#UWBDash.MainWindow.open_current_text_log_file">open_current_text_log_file</a></code></li>
<li><code><a title="UWBDash.MainWindow.open_current_text_log_file2" href="#UWBDash.MainWindow.open_current_text_log_file2">open_current_text_log_file2</a></code></li>
<li><code><a title="UWBDash.MainWindow.open_highlight_config_dialog" href="#UWBDash.MainWindow.open_highlight_config_dialog">open_highlight_config_dialog</a></code></li>
<li><code><a title="UWBDash.MainWindow.open_log_folder" href="#UWBDash.MainWindow.open_log_folder">open_log_folder</a></code></li>
<li><code><a title="UWBDash.MainWindow.paintEvent" href="#UWBDash.MainWindow.paintEvent">paintEvent</a></code></li>
<li><code><a title="UWBDash.MainWindow.refresh_ports" href="#UWBDash.MainWindow.refresh_ports">refresh_ports</a></code></li>
<li><code><a title="UWBDash.MainWindow.refresh_ports2" href="#UWBDash.MainWindow.refresh_ports2">refresh_ports2</a></code></li>
<li><code><a title="UWBDash.MainWindow.reload_highlight_config" href="#UWBDash.MainWindow.reload_highlight_config">reload_highlight_config</a></code></li>
<li><code><a title="UWBDash.MainWindow.show_about_dialog" href="#UWBDash.MainWindow.show_about_dialog">show_about_dialog</a></code></li>
<li><code><a title="UWBDash.MainWindow.show_find_dialog2" href="#UWBDash.MainWindow.show_find_dialog2">show_find_dialog2</a></code></li>
<li><code><a title="UWBDash.MainWindow.show_help_dialog" href="#UWBDash.MainWindow.show_help_dialog">show_help_dialog</a></code></li>
<li><code><a title="UWBDash.MainWindow.switch_page" href="#UWBDash.MainWindow.switch_page">switch_page</a></code></li>
<li><code><a title="UWBDash.MainWindow.theme_changed" href="#UWBDash.MainWindow.theme_changed">theme_changed</a></code></li>
<li><code><a title="UWBDash.MainWindow.toggle_maximize" href="#UWBDash.MainWindow.toggle_maximize">toggle_maximize</a></code></li>
<li><code><a title="UWBDash.MainWindow.toggle_port" href="#UWBDash.MainWindow.toggle_port">toggle_port</a></code></li>
<li><code><a title="UWBDash.MainWindow.toggle_port2" href="#UWBDash.MainWindow.toggle_port2">toggle_port2</a></code></li>
<li><code><a title="UWBDash.MainWindow.toggle_theme" href="#UWBDash.MainWindow.toggle_theme">toggle_theme</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_chart" href="#UWBDash.MainWindow.update_chart">update_chart</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_current_lines" href="#UWBDash.MainWindow.update_current_lines">update_current_lines</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_current_lines2" href="#UWBDash.MainWindow.update_current_lines2">update_current_lines2</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_display" href="#UWBDash.MainWindow.update_display">update_display</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_display2" href="#UWBDash.MainWindow.update_display2">update_display2</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_find_count" href="#UWBDash.MainWindow.update_find_count">update_find_count</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_find_count2" href="#UWBDash.MainWindow.update_find_count2">update_find_count2</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_max_lines" href="#UWBDash.MainWindow.update_max_lines">update_max_lines</a></code></li>
<li><code><a title="UWBDash.MainWindow.update_max_lines2" href="#UWBDash.MainWindow.update_max_lines2">update_max_lines2</a></code></li>
<li><code><a title="UWBDash.MainWindow.wheelEvent" href="#UWBDash.MainWindow.wheelEvent">wheelEvent</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.Particle" href="#UWBDash.Particle">Particle</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.Particle.reset" href="#UWBDash.Particle.reset">reset</a></code></li>
<li><code><a title="UWBDash.Particle.update" href="#UWBDash.Particle.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.ParticleEffectWidget" href="#UWBDash.ParticleEffectWidget">ParticleEffectWidget</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.ParticleEffectWidget.hideEvent" href="#UWBDash.ParticleEffectWidget.hideEvent">hideEvent</a></code></li>
<li><code><a title="UWBDash.ParticleEffectWidget.paintEvent" href="#UWBDash.ParticleEffectWidget.paintEvent">paintEvent</a></code></li>
<li><code><a title="UWBDash.ParticleEffectWidget.resizeEvent" href="#UWBDash.ParticleEffectWidget.resizeEvent">resizeEvent</a></code></li>
<li><code><a title="UWBDash.ParticleEffectWidget.showEvent" href="#UWBDash.ParticleEffectWidget.showEvent">showEvent</a></code></li>
<li><code><a title="UWBDash.ParticleEffectWidget.start_animation" href="#UWBDash.ParticleEffectWidget.start_animation">start_animation</a></code></li>
<li><code><a title="UWBDash.ParticleEffectWidget.stop_animation" href="#UWBDash.ParticleEffectWidget.stop_animation">stop_animation</a></code></li>
<li><code><a title="UWBDash.ParticleEffectWidget.update_particles_and_repaint" href="#UWBDash.ParticleEffectWidget.update_particles_and_repaint">update_particles_and_repaint</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.PositionView" href="#UWBDash.PositionView">PositionView</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.PositionView.create_static_content" href="#UWBDash.PositionView.create_static_content">create_static_content</a></code></li>
<li><code><a title="UWBDash.PositionView.draw_static_content" href="#UWBDash.PositionView.draw_static_content">draw_static_content</a></code></li>
<li><code><a title="UWBDash.PositionView.paintEvent" href="#UWBDash.PositionView.paintEvent">paintEvent</a></code></li>
<li><code><a title="UWBDash.PositionView.update_position" href="#UWBDash.PositionView.update_position">update_position</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.SerialReadThread" href="#UWBDash.SerialReadThread">SerialReadThread</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.SerialReadThread.data_received" href="#UWBDash.SerialReadThread.data_received">data_received</a></code></li>
<li><code><a title="UWBDash.SerialReadThread.run" href="#UWBDash.SerialReadThread.run">run</a></code></li>
<li><code><a title="UWBDash.SerialReadThread.stop" href="#UWBDash.SerialReadThread.stop">stop</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="UWBDash.ThemeManager" href="#UWBDash.ThemeManager">ThemeManager</a></code></h4>
<ul class="">
<li><code><a title="UWBDash.ThemeManager.DARK_THEME" href="#UWBDash.ThemeManager.DARK_THEME">DARK_THEME</a></code></li>
<li><code><a title="UWBDash.ThemeManager.LIGHT_THEME" href="#UWBDash.ThemeManager.LIGHT_THEME">LIGHT_THEME</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
